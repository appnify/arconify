{
  "version": 3,
  "sources": ["../../../node_modules/@vexip-ui/utils/dist/index.mjs", "../../../node_modules/@vexip-ui/hooks/src/listener.ts", "../../../node_modules/@vexip-ui/hooks/src/clickoutside.ts", "../../../node_modules/@vexip-ui/hooks/src/display.ts", "../../../node_modules/@vexip-ui/hooks/src/shared/utils.ts", "../../../node_modules/@vexip-ui/hooks/src/full-screen.ts", "../../../node_modules/@vexip-ui/hooks/src/hover.ts", "../../../node_modules/@vexip-ui/hooks/src/intersection.ts", "../../../node_modules/@vexip-ui/hooks/src/manual-ref.ts", "../../../node_modules/@vexip-ui/hooks/src/modifier.ts", "../../../node_modules/@vexip-ui/hooks/src/mounted.ts", "../../../node_modules/@vexip-ui/hooks/src/moving.ts", "../../../node_modules/@vexip-ui/hooks/src/pointer.ts", "../../../node_modules/node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../../../node_modules/node_modules/.pnpm/@floating-ui+core@1.5.1/node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../../../node_modules/node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs", "../../../node_modules/node_modules/.pnpm/@floating-ui+dom@1.5.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/freeze.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/element.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/global.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/process.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/scheduler.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObservation.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js", "../../../node_modules/node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserver.js", "../../../node_modules/@vexip-ui/hooks/src/resize.ts", "../../../node_modules/@vexip-ui/hooks/src/rtl.ts", "../../../node_modules/@vexip-ui/hooks/src/popper.ts", "../../../node_modules/@vexip-ui/hooks/src/theme.ts", "../../../node_modules/@vexip-ui/hooks/src/timer-record.ts", "../../../node_modules/@vexip-ui/hooks/src/trigger-handler.ts", "../../../node_modules/@vexip-ui/hooks/src/virtual.ts"],
  "sourcesContent": ["const y = typeof window < \"u\";\nvar At;\nconst gn = y && ((At = window == null ? void 0 : window.navigator) == null ? void 0 : At.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent), te = Object.prototype.toString, ee = Object.prototype.hasOwnProperty;\nfunction B(t, e) {\n  return te.call(t) === `[object ${e}]`;\n}\nfunction pn(t, e) {\n  return ee.call(t, e);\n}\nfunction w(t) {\n  return t != null;\n}\nfunction ne(t) {\n  return t == null;\n}\nfunction mn(t) {\n  return typeof t == \"number\";\n}\nfunction re(t) {\n  return Number.isNaN(t);\n}\nfunction bn(t) {\n  return typeof t == \"string\";\n}\nfunction yn(t) {\n  return typeof t == \"boolean\";\n}\nfunction Mn(t) {\n  return t === !0;\n}\nfunction Sn(t) {\n  return t === !1;\n}\nfunction wn(t) {\n  return typeof t == \"symbol\";\n}\nfunction En(t) {\n  return typeof t == \"bigint\";\n}\nfunction Nn(t) {\n  return Array.isArray(t);\n}\nfunction Y(t) {\n  return B(t, \"Object\");\n}\nfunction An(t) {\n  return !!t && typeof t.then == \"function\" && typeof t.catch == \"function\";\n}\nfunction Ft(t) {\n  return typeof t == \"function\";\n}\nfunction Fn(t) {\n  return B(t, \"Set\");\n}\nfunction Tn(t) {\n  return B(t, \"Map\");\n}\nfunction On(t) {\n  return B(t, \"Date\");\n}\nfunction $n(t) {\n  return B(t, \"RegExp\");\n}\nfunction Rn(t) {\n  return Array.isArray(t) || typeof t == \"string\" ? t.length === 0 : t instanceof Map || t instanceof Set ? t.size === 0 : Y(t) ? Object.keys(t).length === 0 : typeof t == \"number\" ? re(t) : ne(t);\n}\nfunction _n(t, e = !1) {\n  return !e && !y ? !1 : !!(t && \"nodeType\" in t);\n}\nfunction W(t) {\n  return w(t) && typeof t[Symbol.iterator] == \"function\";\n}\nfunction ot() {\n}\nfunction oe() {\n  return !0;\n}\nfunction kn() {\n  return !1;\n}\nfunction Cn(t, e = 1, n = 1) {\n  const r = [];\n  for (let o = 0; o < t; ++o)\n    r.push(e + o * n);\n  return r;\n}\nfunction ie(t) {\n  return Object.prototype.toString.call(t).slice(8, -1);\n}\nfunction xn(t = 16) {\n  const e = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\", n = e.length;\n  let r = \"\";\n  for (; t--; )\n    r += e.charAt(Math.floor(Math.random() * n));\n  return r;\n}\nasync function Dn(t, e = {}) {\n  if (t.length) {\n    for (const [n, r] of t)\n      if (typeof n == \"function\" ? n() : n)\n        return typeof e.beforeMatchAny == \"function\" && await e.beforeMatchAny(), await r(), typeof e.afterMatchAny == \"function\" && await e.afterMatchAny(), !0;\n  }\n  return !1;\n}\nasync function In(t) {\n  if (!y)\n    return !1;\n  try {\n    return await navigator.clipboard.writeText(t), !0;\n  } catch {\n    let e = !1;\n    const n = document.createElement(\"textarea\"), r = document.activeElement;\n    n.value = t, n.setAttribute(\"readonly\", \"\"), n.style.contain = \"strict\", n.style.position = \"absolute\", n.style.height = \"0\", n.style.fontSize = \"12pt\";\n    const o = document.getSelection(), i = o ? o.rangeCount > 0 && o.getRangeAt(0) : null;\n    return document.body.appendChild(n), n.select(), n.selectionStart = 0, n.selectionEnd = t.length, e = document.execCommand(\"copy\"), document.body.removeChild(n), i && (o.removeAllRanges(), o.addRange(i)), r && r.focus(), e;\n  }\n}\nconst se = \"[-\\\\+]?\\\\d+%?\", ce = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\", F = `(?:${ce})|(?:${se})`, ae = `[\\\\s|\\\\(]+(${F})[,|\\\\s]+(${F})[,|\\\\s]+(${F})\\\\s*\\\\)?`, U = `[\\\\s|\\\\(]+(${F})[,|\\\\s]+(${F})[,|\\\\s]+(${F})[,|\\\\s]+(${F})\\\\s*\\\\)?`, Tt = new RegExp(`rgb${ae}`), Ot = new RegExp(`rgba${U}`), $t = new RegExp(`hsl${U}`), Rt = new RegExp(`hsla${U}`), _t = new RegExp(`hsv${U}`), kt = new RegExp(`hsva${U}`), Ct = /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, xt = /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Dt = /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, It = /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, G = Object.freeze({\n  aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\"\n}), fe = Object.freeze(new Set(Object.keys(G)));\nfunction Ln(t) {\n  return t = String(t).trim().toLowerCase(), t ? t === \"transparent\" || G[t] ? !0 : t === \"transparent\" || fe.has(t) || Tt.test(t) || Ot.test(t) || $t.test(t) || Rt.test(t) || _t.test(t) || kt.test(t) || Ct.test(t) || xt.test(t) || Dt.test(t) || It.test(t) : !1;\n}\nfunction ue(t) {\n  if (t = t.toString().trim().toLowerCase(), t === \"transparent\")\n    return { r: 0, g: 0, b: 0, a: 0, format: \"name\", toString: M };\n  let e = !1;\n  G[t] && (t = G[t], e = !0);\n  let n;\n  if (n = Tt.exec(t)) {\n    const { r, g: o, b: i } = _(n[1], n[2], n[3]);\n    return {\n      r: r * 255,\n      g: o * 255,\n      b: i * 255,\n      format: \"rgb\",\n      toString: M\n    };\n  }\n  if (n = Ot.exec(t)) {\n    const { r, g: o, b: i } = _(n[1], n[2], n[3]);\n    return {\n      r: r * 255,\n      g: o * 255,\n      b: i * 255,\n      a: R(n[4]),\n      format: \"rgba\",\n      toString: M\n    };\n  }\n  if (n = $t.exec(t)) {\n    const { h: r, s: o, l: i } = z(n[0], n[1], n[3]);\n    return { h: r * 360, s: o, l: i, format: \"hsl\", toString: H };\n  }\n  if (n = Rt.exec(t)) {\n    const { h: r, s: o, l: i } = z(n[0], n[1], n[3]);\n    return {\n      h: r * 360,\n      s: o,\n      l: i,\n      a: R(n[4]),\n      format: \"hsla\",\n      toString: H\n    };\n  }\n  if (n = _t.exec(t)) {\n    const { h: r, s: o, v: i } = q(n[0], n[1], n[3]);\n    return { h: r * 360, s: o, v: i, format: \"hsv\", toString: j };\n  }\n  if (n = kt.exec(t)) {\n    const { h: r, s: o, v: i } = q(n[0], n[1], n[3]);\n    return {\n      h: r * 360,\n      s: o,\n      v: i,\n      a: R(n[4]),\n      format: \"hsva\",\n      toString: j\n    };\n  }\n  return (n = Ct.exec(t)) ? {\n    r: parseInt(`${n[1]}${n[1]}`, 16),\n    g: parseInt(`${n[2]}${n[2]}`, 16),\n    b: parseInt(`${n[3]}${n[3]}`, 16),\n    format: e ? \"name\" : \"hex3\",\n    toString: M\n  } : (n = xt.exec(t)) ? {\n    r: parseInt(`${n[1]}${n[1]}`, 16),\n    g: parseInt(`${n[2]}${n[2]}`, 16),\n    b: parseInt(`${n[3]}${n[3]}`, 16),\n    a: pt(`${n[4]}${n[4]}`),\n    format: e ? \"name\" : \"hex4\",\n    toString: M\n  } : (n = Dt.exec(t)) ? {\n    r: parseInt(n[1], 16),\n    g: parseInt(n[2], 16),\n    b: parseInt(n[3], 16),\n    format: e ? \"name\" : \"hex6\",\n    toString: M\n  } : (n = It.exec(t)) ? {\n    r: parseInt(n[1], 16),\n    g: parseInt(n[2], 16),\n    b: parseInt(n[3], 16),\n    a: pt(n[4]),\n    format: e ? \"name\" : \"hex8\",\n    toString: M\n  } : null;\n}\nfunction Hn(t) {\n  const { a: e, ...n } = T(t);\n  delete n.format;\n  const r = Ht(n.r, n.g, n.b), o = Pt(n.r, n.g, n.b), i = it(n.r, n.g, n.b), s = st(n.r, n.g, n.b, e);\n  return {\n    rgb: n,\n    hsl: r,\n    hsv: o,\n    hex: i,\n    alpha: e,\n    rgba: { ...n, a: e, format: \"rgba\" },\n    hsla: { ...r, a: e, format: \"hsla\" },\n    hsva: { ...o, a: e, format: \"hsva\" },\n    hex8: s,\n    gray: Ut(n),\n    origin: t\n  };\n}\nfunction T(t) {\n  let e = { r: 0, g: 0, b: 0 }, n = 1, r;\n  return typeof t == \"string\" ? r = ue(t) : r = t, r !== null && typeof r == \"object\" && (\"l\" in r ? e = Lt(r.h, r.s, r.l) : \"v\" in r && (e = de(r.h, r.s, r.v)), \"a\" in r && (n = R(r.a ?? 1), Number.isNaN(n) && (n = 1)), e = r), { ...e, a: n, format: \"rgba\", toString: M };\n}\nfunction z(t, e, n) {\n  return {\n    h: S(t, 0, 360) / 360,\n    s: S(I(e) ? L(e) : e, 0, 1),\n    l: S(I(n) ? L(n) : n, 0, 1)\n  };\n}\nfunction _(t, e, n) {\n  return {\n    r: S(t, 0, 255) / 255,\n    g: S(e, 0, 255) / 255,\n    b: S(n, 0, 255) / 255\n  };\n}\nfunction q(t, e, n) {\n  return {\n    h: S(t, 0, 360) / 360,\n    s: S(I(e) ? L(e) : e, 0, 1),\n    v: S(I(n) ? L(n) : n, 0, 1)\n  };\n}\nfunction R(t) {\n  return S(I(t) ? L(t) : t, 0, 1);\n}\nfunction Lt(t, e, n) {\n  let r, o, i;\n  if ({ h: t, s: e, l: n } = z(t, e, n), e === 0)\n    r = o = i = n;\n  else {\n    const s = n < 0.5 ? 1 * (1 + e) : n + e - n * e, c = 2 * n - s;\n    r = tt(c, s, t + 1 / 3), o = tt(c, s, t), i = tt(c, s, t - 1 / 3);\n  }\n  return r *= 255, o *= 255, i *= 255, { r, g: o, b: i, toString: M };\n}\nfunction Ht(t, e, n) {\n  ({ r: t, g: e, b: n } = _(t, e, n));\n  const r = Math.max(t, e, n), o = Math.min(t, e, n);\n  let i, s;\n  const c = (r + o) / 2;\n  if (r === o)\n    i = s = 0;\n  else {\n    const a = r - o;\n    switch (s = c > 0.5 ? a / (2 - r - o) : a / (r + o), r) {\n      case t: {\n        i = (e - n) / a + (e < n ? 6 : 0);\n        break;\n      }\n      case e: {\n        i = (n - t) / a + 2;\n        break;\n      }\n      case n: {\n        i = (t - e) / a + 4;\n        break;\n      }\n      default:\n        i = 0;\n    }\n    i *= 60;\n  }\n  return { h: i, s, l: c, toString: H };\n}\nfunction le(t, e, n) {\n  ({ h: t, s: e, l: n } = z(t, e, n));\n  const r = 0.5 * (2 * n + e * (1 - Math.abs(2 * n - 1)));\n  return e = 2 * (r - n) / r, { h: t * 360, s: e, v: r, toString: j };\n}\nfunction Pn(t, e, n) {\n  ({ h: t, s: e, v: n } = q(t, e, n));\n  const r = 0.5 * n * (2 - e);\n  return e = n * e / (1 - Math.abs(2 * r - 1)), { h: t * 360, s: e, l: r, toString: H };\n}\nfunction de(t, e, n) {\n  ({ h: t, s: e, v: n } = q(t, e, n)), t *= 6;\n  const r = Math.floor(t), o = t - r, i = n * (1 - e), s = n * (1 - o * e), c = n * (1 - (1 - o) * e), a = r % 6;\n  let f = [n, s, i, i, c, n][a], u = [c, n, n, s, i, i][a], d = [i, i, c, n, n, s][a];\n  return f *= 255, u *= 255, d *= 255, { r: f, g: u, b: d, toString: M };\n}\nfunction Pt(t, e, n) {\n  ({ r: t, g: e, b: n } = _(t, e, n));\n  const r = Math.max(t, e, n), o = Math.min(t, e, n);\n  let i;\n  const s = r, c = r - o, a = r === 0 ? 0 : c / r;\n  if (r === o)\n    i = 0;\n  else {\n    switch (r) {\n      case t: {\n        i = (e - n) / c + (e < n ? 6 : 0);\n        break;\n      }\n      case e: {\n        i = (n - t) / c + 2;\n        break;\n      }\n      case n: {\n        i = (t - e) / c + 4;\n        break;\n      }\n      default:\n        i = 0;\n    }\n    i *= 60;\n  }\n  return { h: i, s: a, v: s, toString: j };\n}\nfunction it(t, e, n, r = !1) {\n  ({ r: t, g: e, b: n } = _(t, e, n));\n  const o = [\n    O(Math.round(t * 255).toString(16)),\n    O(Math.round(e * 255).toString(16)),\n    O(Math.round(n * 255).toString(16))\n  ];\n  return r && $(o[0]) && $(o[1]) && $(o[2]) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) : \"#\" + o.join(\"\");\n}\nfunction st(t, e, n, r, o = !1) {\n  ({ r: t, g: e, b: n } = _(t, e, n));\n  const i = [\n    O(Math.round(t * 255).toString(16)),\n    O(Math.round(e * 255).toString(16)),\n    O(Math.round(n * 255).toString(16)),\n    O(he(R(r)))\n  ];\n  return o && $(i[0]) && $(i[1]) && $(i[2]) && $(i[3]) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) + i[3].charAt(0) : \"#\" + i.join(\"\");\n}\nfunction Bn(t, e, n = 0.5) {\n  if (!t && !e)\n    return { r: 0, g: 0, b: 0, a: 1 };\n  if (!t)\n    return T(e);\n  if (!e)\n    return T(t);\n  const r = T(t), o = T(e), i = S(n, 0, 1), s = i * 2 - 1, c = r.a - o.a, f = ((s * c === -1 ? s : (s + c) / (1 + s * c)) + 1) / 2, u = 1 - f;\n  return {\n    r: Math.round(r.r * f + o.r * u),\n    g: Math.round(r.g * f + o.g * u),\n    b: Math.round(r.b * f + o.b * u),\n    a: Math.round(r.a * i + o.a * (1 - i)),\n    format: \"rgba\",\n    toString: M\n  };\n}\nfunction Un(t, e) {\n  const n = T(t);\n  return n.a = R(e), n;\n}\nfunction Yn(t = !1, e = \"hex\") {\n  const n = Math.round(Math.random() * 255), r = Math.round(Math.random() * 255), o = Math.round(Math.random() * 255);\n  if (e === \"hex\")\n    return t ? st(n, r, o, Math.random()) : it(n, r, o);\n  let i;\n  return e === \"hsl\" ? i = Ht(n, r, o) : e === \"hsv\" ? i = Pt(n, r, o) : i = /* @__PURE__ */ Object.create({ r: n, g: r, b: o, toString: M }), t && (i.a = Math.random()), i.toString();\n}\nfunction Bt(t, e = !1, n = \"hex\") {\n  const r = Math.round(Math.random() * 360), o = Math.round(t === \"hard\" ? 80 + Math.random() * 20 : 20 + Math.random() * 70) / 100, i = Math.round(t === \"hard\" ? 40 + Math.random() * 20 : 80 + Math.random() * 15) / 100;\n  if (n === \"hsl\")\n    return H.bind({ h: r, s: o, l: i })();\n  let s;\n  if (n === \"hex\" || n === \"rgb\") {\n    if (s = Lt(r, o, i), n === \"hex\") {\n      const { r: c, g: a, b: f } = s;\n      return e ? st(c, a, f, Math.random()) : it(c, a, f);\n    }\n  } else\n    n === \"hsv\" && (s = le(r, o, i));\n  return e && (s.a = Math.random()), s.toString();\n}\nfunction Wn(t = !1, e = \"hex\") {\n  return Bt(\"hard\", t, e);\n}\nfunction Gn(t = !1, e = \"hex\") {\n  return Bt(\"soft\", t, e);\n}\nfunction zn(t) {\n  return Ut(T(t));\n}\nfunction O(t) {\n  return t.length === 1 ? `0${t}` : t.toString();\n}\nfunction $(t) {\n  return t.charAt(0) === t.charAt(1);\n}\nfunction he(t) {\n  return Math.round(parseFloat(t) * 255).toString(16);\n}\nfunction pt(t) {\n  return parseInt(t, 16) / 255;\n}\nfunction S(t, e, n) {\n  return Math.max(e, Math.min(n, parseFloat(t)));\n}\nfunction tt(t, e, n) {\n  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;\n}\nfunction I(t) {\n  return String(t).trim().includes(\"%\");\n}\nfunction L(t) {\n  const e = parseFloat(t) / 100;\n  return Number.isNaN(e) ? 0 : e;\n}\nfunction M() {\n  return w(this.a) && this.a >= 0 && this.a < 1 ? `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})` : `rgb(${this.r}, ${this.g}, ${this.b})`;\n}\nfunction H() {\n  const t = `${this.s * 100}%`, e = `${this.l * 100}%`;\n  return w(this.a) && this.a >= 0 && this.a < 1 ? `hsla(${this.h}, ${t}, ${e}, ${this.a})` : `hsl(${this.h}, ${t}, ${e})`;\n}\nfunction j() {\n  const t = `${this.s * 100}%`, e = `${this.v * 100}%`;\n  return w(this.a) && this.a >= 0 && this.a < 1 ? `hsva(${this.h}, ${t}, ${e}, ${this.a})` : `hsv(${this.h}, ${t}, ${e})`;\n}\nfunction Ut(t) {\n  return (t.r * 0.2126 + t.g * 0.7152 + t.b * 0.0722) / 255;\n}\nfunction mt(t) {\n  return t & -t;\n}\nfunction qn(t, e = 0) {\n  const n = new Array(t + 1).fill(0);\n  function r(c, a) {\n    if (!(!a || c >= t))\n      for (c += 1; c <= t; )\n        n[c] += a, c += mt(c);\n  }\n  function o(c = t) {\n    if (c <= 0)\n      return 0;\n    c > t && (c = t);\n    let a = c * e;\n    for (; c > 0; )\n      a += n[c], c -= mt(c);\n    return a;\n  }\n  function i(c) {\n    return o(c + 1) - o(c);\n  }\n  function s(c) {\n    let a = 0, f = t;\n    for (; f > a; ) {\n      const u = Math.floor((a + f) / 2), d = o(u);\n      if (d > c) {\n        f = u;\n        continue;\n      } else if (d < c) {\n        if (a === u)\n          return o(a + 1) <= c ? a + 1 : a;\n        a = u;\n      } else\n        return u;\n    }\n    return a;\n  }\n  return { tree: n, add: r, sum: o, get: i, boundIndex: s };\n}\nconst ge = /^\\s*[+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?\\s*$/;\nfunction pe(t, e = !1) {\n  return typeof t == \"number\" ? !Number.isNaN(t) : e ? ge.test(String(t)) : !Number.isNaN(parseFloat(t)) || !Number.isNaN(Number(t));\n}\nfunction me(t) {\n  let e = parseFloat(t);\n  return Number.isNaN(e) && (e = Number(t)), Number.isNaN(e) ? 0 : e;\n}\nfunction be(t, e) {\n  return e <= 0 ? t.toString() : `${t < 0 ? \"-\" : \"\"}${String(Math.abs(Math.round(t))).padStart(e, \"0\")}`;\n}\nfunction N(t) {\n  return be(t, 2);\n}\nfunction E(t) {\n  const e = t.toString().split(/[eE]/), n = (e[0].split(\".\")[1] || \"\").length - +(e[1] || 0);\n  return n > 0 ? n : 0;\n}\nfunction jn(t) {\n  return E(t);\n}\nfunction Kn(t, e = 3, n = \",\") {\n  if (typeof t != \"number\" && (t = parseFloat(t)), Number.isNaN(t))\n    return \"0\";\n  let [r, o] = String(t).split(\".\");\n  const i = new RegExp(`(\\\\d+)(\\\\d{${e}})`);\n  for (; i.test(r); )\n    r = r.replace(i, `$1${n}$2`);\n  return o = o ? `.${o}` : \"\", `${r}${o}`;\n}\nfunction Yt(t, e) {\n  if (e === 0)\n    return Math.round(t);\n  let n = t.toFixed(E(t));\n  const r = n.indexOf(\".\");\n  if (r === -1)\n    return t;\n  const o = n.replace(\".\", \"\").split(\"\"), i = r + e;\n  return o[i] ? (n.charAt(i + 1) === \"5\" ? n = n.substring(0, i + 1) + \"6\" : n = n.substring(0, i + 2), parseFloat(Number(n).toFixed(e))) : t;\n}\nfunction Qn(t, e, n) {\n  return Yt(t * e, n);\n}\nfunction Xn(t, e) {\n  if (e < 0 || e > 1)\n    return Math.round(t);\n  const n = Math.ceil(t);\n  return t + 1 - e >= n ? n : Math.floor(t);\n}\nfunction Zn(t, e, n) {\n  return Math.max(e, Math.min(n, parseFloat(t)));\n}\nfunction Vn(t, e, n = 0) {\n  if (t <= 0 || e <= 1)\n    return [t];\n  n < 1 && (n = 1 / 0);\n  const r = [];\n  let o = 0;\n  for (; t >= e && o < n; )\n    r.push(t % e), t = Math.floor(t / e), ++o;\n  return r.push(t), r.reverse();\n}\nconst bt = Object.freeze([\n  \"B\",\n  \"KB\",\n  \"MB\",\n  \"GB\",\n  \"TB\",\n  \"AUTO\"\n]);\nfunction vn(t, e = \"AUTO\", n = !1, r) {\n  typeof r > \"u\" && (typeof n == \"number\" ? (r = n, n = !1) : r = 2);\n  let o = e.toUpperCase();\n  o = bt.includes(o) ? o : \"AUTO\";\n  let i;\n  switch (o) {\n    case \"AUTO\":\n      i = 0;\n      break;\n    case \"KB\":\n      i = 1;\n      break;\n    case \"MB\":\n      i = 2;\n      break;\n    case \"GB\":\n      i = 3;\n      break;\n    case \"TB\":\n      i = 4;\n      break;\n    default:\n      return t;\n  }\n  let s;\n  if (i)\n    s = t / 1024 ** i;\n  else\n    for (s = t; s > 1024 && !(i > 4); ++i)\n      s = s / 1024;\n  return s = Yt(s, r), n ? `${s}${o === \"AUTO\" ? bt[Math.min(i, 4)] : o}` : s;\n}\nfunction Jn(t, e = 0) {\n  return e === t ? e : (e > t && ([e, t] = [t, e]), Math.random() * (t - e) + e);\n}\nfunction Wt(t, e = 15) {\n  return +parseFloat(Number(t).toPrecision(e));\n}\nfunction K(t) {\n  const e = String(t);\n  if (!e.includes(\"e\"))\n    return Number(e.replace(\".\", \"\"));\n  const n = E(t);\n  return n > 0 ? Wt(Number(t) * 10 ** n) : Number(t);\n}\nfunction Q(t) {\n  return (...e) => {\n    let n = e[0];\n    for (let r = 1, o = e.length; r < o; ++r)\n      n = t(n, e[r]);\n    return n;\n  };\n}\nconst P = Q((t, e) => {\n  const n = K(t), r = K(e), o = E(t) + E(e);\n  return n * r / 10 ** o;\n}), tr = Q((t, e) => {\n  const n = 10 ** Math.max(E(t), E(e));\n  return (P(t, n) + P(e, n)) / n;\n}), er = Q((t, e) => {\n  const n = 10 ** Math.max(E(t), E(e));\n  return (P(t, n) - P(e, n)) / n;\n}), nr = Q((t, e) => {\n  const n = K(t), r = K(e);\n  return P(n / r, Wt(10 ** (E(e) - E(t))));\n}), ye = 1e3, A = 1e3, C = 60, Me = C * A, rr = C * A, X = 60, Gt = X * C, Se = Gt * A, or = Gt * A, zt = 24, we = zt * X, qt = we * C, Ee = qt * A, ir = qt * A, ct = 7, Ne = ct * zt, Ae = Ne * X, jt = Ae * C, Fe = jt * A, sr = jt * A, Kt = 3, Te = 4, Oe = Te * Kt, $e = {\n  y(t, e) {\n    const n = t.getFullYear();\n    return e.length === 4 ? n : n % 1e3 % 100;\n  },\n  M(t, e) {\n    const n = t.getMonth() + 1;\n    return e.length === 2 ? N(n) : n;\n  },\n  d(t, e) {\n    const n = t.getDate();\n    return e.length === 2 ? N(n) : n;\n  },\n  H(t, e) {\n    const n = t.getHours();\n    return e.length === 2 ? N(n) : n;\n  },\n  m(t, e) {\n    const n = t.getMinutes();\n    return e.length === 2 ? N(n) : n;\n  },\n  s(t, e) {\n    const n = t.getSeconds();\n    return e.length === 2 ? N(n) : n;\n  },\n  q(t, e) {\n    const n = Math.ceil((t.getMonth() + 1) / 3);\n    return e.length === 2 ? N(n) : n;\n  }\n}, Re = /[yMdHmsq](\\w)*|./g, _e = /'(.+?)'/g;\nfunction h(t, e = !1) {\n  const n = new Date(t);\n  if (e && Number.isNaN(+n))\n    throw new RangeError(\"Invalid date value\");\n  return typeof t == \"string\" && !t.includes(\":\") && (n.setHours(0), n.setMinutes(0), n.setSeconds(0)), n;\n}\nfunction cr(t, e = \"yyyy-MM-dd HH:mm:ss\") {\n  t = h(t);\n  const n = e.match(Re), r = n == null ? void 0 : n.length;\n  if (!r)\n    return e;\n  let o = 0, i = \"\";\n  for (; o < r; ) {\n    const s = n[o], c = s[0], a = $e[c];\n    a ? i += a(t, s) : i += s, ++o;\n  }\n  return i.replace(_e, \"$1\");\n}\nfunction ar(t) {\n  return t = h(t), `${N(t.getHours())}:${N(t.getMinutes())}:${N(\n    t.getSeconds()\n  )}`;\n}\nfunction rt(t) {\n  return t = h(t), Math.floor(t.getMonth() / 3) + 1;\n}\nconst ke = [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"];\nfunction fr(t) {\n  return ke[t.getDay()];\n}\nfunction Ce(t, e) {\n  return t = h(t), t.setTime(t.getTime() + e), t;\n}\nfunction xe(t, e) {\n  return e *= A, Ce(t, e);\n}\nfunction De(t, e) {\n  return e *= C, xe(t, e);\n}\nfunction Ie(t, e) {\n  return e *= X, De(t, e);\n}\nfunction ur(t, e) {\n  return e *= 12, Ie(t, e);\n}\nfunction at(t, e) {\n  return t = h(t), e = ~~e, t.setDate(t.getDate() + e), t;\n}\nfunction lr(t, e) {\n  return e *= ct, at(t, e);\n}\nfunction ft(t, e) {\n  return t = h(t), e = ~~e, t.setMonth(t.getMonth() + e), t;\n}\nfunction dr(t, e) {\n  return e *= Kt, ft(t, e);\n}\nfunction hr(t, e) {\n  return e *= Oe, ft(t, e);\n}\nfunction gr(t, e = 42, n = 1) {\n  t = h(t);\n  const r = [];\n  for (let o = 0; o < e; ++o)\n    r.push(at(t, o * n));\n  return r;\n}\nfunction pr(t, e = 12, n = 1) {\n  t = h(t);\n  const r = [];\n  for (let o = 0; o < e; ++o)\n    r.push(ft(t, o * n));\n  return r;\n}\nfunction mr(t) {\n  const e = t.getDay() ?? 7;\n  return at(t, -e);\n}\nfunction yt(t) {\n  return t = h(t), t.setMilliseconds(0), t;\n}\nfunction Mt(t) {\n  return t = h(t), t.setSeconds(0, 0), t;\n}\nfunction St(t) {\n  return t = h(t), t.setMinutes(0, 0, 0), t;\n}\nfunction wt(t) {\n  return t = h(t), t.setHours(0, 0, 0, 0), t;\n}\nfunction br(t) {\n  return t = h(t), t.setHours(23, 59, 59, 999), t;\n}\nfunction Et(t, e = 0) {\n  e = e % 7, e < 0 && (e += 7), t = h(t);\n  const n = t.getDay(), r = (n < e ? 7 : 0) + n - e;\n  return t.setDate(t.getDate() - r), t.setHours(0, 0, 0, 0), t;\n}\nfunction Le(t) {\n  return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0;\n}\nfunction yr(t, e = 1) {\n  t = h(t);\n  const n = t.getFullYear(), r = t.getMonth() + 1, o = t.getDate();\n  let i;\n  return r < 7 ? r !== 2 ? i = 30 + r % 2 : Le(n) ? i = 29 : i = 28 : i = 31 - r % 2, e = e % i, e < 0 && (e += i), o < e && t.setMonth(r - 1), t.setDate(e), t.setHours(0, 0, 0, 0), t;\n}\nfunction Mr(t) {\n  t = h(t);\n  const e = rt(t);\n  return t.setDate(1), t.setHours(0, 0, 0, 0), t.setMonth((e - 1) * 3), t;\n}\nfunction Sr(t, e = 0) {\n  e = e % 11, e < 0 && (e += 11), t = h(t);\n  const n = t.getMonth(), r = (n < e ? 11 : 0) + n - e;\n  return t.setMonth(t.getMonth() - r), t.setDate(1), t.setHours(0, 0, 0, 0), t;\n}\nfunction ut(t, e) {\n  return t = h(t), e = h(e), e.getTime() - t.getTime();\n}\nfunction He(t, e) {\n  const n = ut(t, e) / ye;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction Pe(t, e) {\n  const n = ut(t, e) / Me;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction Be(t, e) {\n  const n = ut(t, e) / Se;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction Ue(t, e) {\n  return t = wt(t), e = wt(e), (e.getTime() - t.getTime()) / Ee;\n}\nfunction wr(t, e, n = 0) {\n  return t = Et(t, n), e = Et(e, n), (e.getTime() - t.getTime()) / Fe;\n}\nfunction Ye(t, e) {\n  t = h(t), e = h(e);\n  const n = e.getFullYear() - t.getFullYear(), r = e.getMonth() - t.getMonth();\n  return n * 12 + r;\n}\nfunction Er(t, e) {\n  t = h(t), e = h(e);\n  const n = e.getFullYear() - t.getFullYear(), r = rt(e) - rt(t);\n  return n * 4 + r;\n}\nfunction We(t, e) {\n  return t = h(t), e = h(e), e.getFullYear() - t.getFullYear();\n}\nfunction Ge(t, e) {\n  t = h(t), e = h(e);\n  const n = t.getTime() - e.getTime();\n  return n < 0 ? -1 : n > 0 ? 1 : n;\n}\nfunction k(t, e) {\n  return -Ge(t, e);\n}\nfunction Nr(t, e) {\n  return t = yt(t), e = yt(e), He(t, e);\n}\nfunction Ar(t, e) {\n  return t = Mt(t), e = Mt(e), Pe(t, e);\n}\nfunction Fr(t, e) {\n  return t = St(t), e = St(e), Be(t, e);\n}\nfunction ze(t, e) {\n  const n = k(t, e), r = Math.abs(Ue(t, e));\n  t = h(t), t.setDate(t.getDate() + n * r);\n  const o = k(t, e) === -n;\n  return n * (r - (o ? 1 : 0));\n}\nfunction Tr(t, e) {\n  const n = ze(t, e) / ct;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction qe(t, e) {\n  const n = k(t, e), r = Math.abs(Ye(t, e));\n  t = h(t), t.setMonth(t.getMonth() + n * r);\n  const o = k(t, e) === -n;\n  return n * (r - (o ? 1 : 0));\n}\nfunction Or(t, e) {\n  const n = qe(t, e) / 3;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction $r(t, e) {\n  const n = k(t, e), r = Math.abs(We(t, e));\n  t = h(t), t.setFullYear(t.getFullYear() + n * r);\n  const o = k(t, e) === -n;\n  return n * (r - (o ? 1 : 0));\n}\nfunction je(t, e = {}) {\n  if (t == null || typeof t != \"object\")\n    return t;\n  const { cloneObject: n = ot } = e, r = {}, o = [\n    {\n      parent: r,\n      prop: \"root\",\n      data: t\n    }\n  ], i = /* @__PURE__ */ new WeakMap(), s = [], c = [];\n  for (; o.length; ) {\n    const { parent: a, prop: f, data: u } = o.pop();\n    if (!a)\n      continue;\n    const d = ie(u);\n    if (d === \"Date\") {\n      a[f] = new Date(u);\n      continue;\n    }\n    if (d !== \"Array\") {\n      const l = n(d, u);\n      if (l != null) {\n        a[f] = l;\n        continue;\n      }\n    }\n    const g = a[f] = d === \"Array\" || d === \"Set\" || d === \"Map\" ? [] : {};\n    if (d === \"Set\" || d === \"Map\") {\n      let l = 0;\n      if (d === \"Set\") {\n        for (const p of u)\n          i.has(p) ? g[l] = i.get(p) : p !== null && typeof p == \"object\" ? o.push({\n            parent: g,\n            prop: l,\n            data: p\n          }) : g[l] = p, ++l;\n        s.push({ parent: a, prop: f });\n      } else {\n        for (const p of u) {\n          const b = [];\n          l = 0;\n          for (const m of p)\n            i.has(m) ? b[l] = i.get(m) : m !== null && typeof m == \"object\" ? o.push({\n              parent: b,\n              prop: l,\n              data: m\n            }) : b[l] = m, ++l;\n          g.push(b);\n        }\n        c.push({ parent: a, prop: f });\n      }\n    } else\n      for (const l of Object.keys(u)) {\n        const p = u[l];\n        i.has(p) ? g[l] = i.get(p) : p !== null && typeof p == \"object\" ? o.push({\n          parent: g,\n          prop: l,\n          data: p\n        }) : g[l] = p;\n      }\n    i.set(u, g);\n  }\n  for (const { parent: a, prop: f } of s)\n    a[f] = new Set(a[f]);\n  for (const { parent: a, prop: f } of c)\n    a[f] = new Map(a[f]);\n  return r.root;\n}\nconst Ke = \"This object was destroyed, do not use it anywhere\", Qe = () => !0;\nfunction Rr(t, e = Ke) {\n  const n = () => {\n    throw new Error(e);\n  };\n  Object.keys(t).forEach((r) => {\n    typeof t[r] == \"function\" ? t[r] = n.bind(t) : t[r] = null;\n  }), Object.getOwnPropertyNames(t.constructor.prototype).forEach((r) => {\n    r !== \"constructor\" && typeof t[r] == \"function\" && (t[r] = n.bind(t));\n  }), t.isDestroyed = Qe;\n}\nconst Xe = y && (\"ontouchstart\" in window || Ze() > 0), _r = Xe ? \"pointerdown\" : \"click\";\nfunction Ze() {\n  return typeof navigator < \"u\" && (navigator.maxTouchPoints || navigator.msMaxTouchPoints) || 0;\n}\nfunction kr(t, e, n = window.Event) {\n  const { type: r, bubbles: o = !1, cancelable: i = !1, ...s } = e;\n  if (!w(r) || r === \"\")\n    return !1;\n  let c;\n  return w(n) ? c = new n(r, { bubbles: o, cancelable: i }) : (c = document.createEvent(\"HTMLEvents\"), c.initEvent(r, o, i)), Object.assign(c, s), t.dispatchEvent(c);\n}\nconst Ve = [\n  \"button\",\n  \"[href]:not(.disabled)\",\n  \"input\",\n  \"select\",\n  \"textarea\",\n  \"[tabindex]\",\n  \"[contenteditable]\"\n].map((t) => `${t}:not(:disabled):not([disabled])`).join(\", \");\nfunction Z(t) {\n  return !!t && t.nodeType === 1;\n}\nfunction ve(t) {\n  return Z(t) ? t : document.body;\n}\nfunction Je(t, e) {\n  return !y || !t ? [] : Array.from(ve(e).querySelectorAll(t));\n}\nfunction Cr(t) {\n  if (!y)\n    return !1;\n  const e = document.activeElement;\n  return !Z(t) || !e ? !1 : t === e || Qt(e, t);\n}\nfunction Qt(t, e) {\n  if (!t || !e)\n    return !1;\n  const n = e.__transferElement;\n  return e.contains(t) || !!n && (n === t || n.contains(t));\n}\nfunction tn(t) {\n  if (!y || !Z(t) || !t.parentNode || !Qt(t, document.body) || t.style.display === \"none\")\n    return !0;\n  const e = t.getBoundingClientRect();\n  return !(e && e.width > 0 && e.height > 0);\n}\nfunction en(t) {\n  return !tn(t);\n}\nfunction nn(t) {\n  return !Z(t) || t.hasAttribute(\"disabled\") && t.getAttribute(\"disabled\") !== \"false\" || t.disabled;\n}\nfunction xr(t, e = !1) {\n  const n = e ? () => !1 : nn;\n  return Je(Ve, t).filter(\n    (r) => en(r) && r.tabIndex > -1 && !n(r)\n  );\n}\nfunction rn(t) {\n  if (!y || !t)\n    return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.paddingLeft) + parseFloat(e.paddingRight) || 0;\n}\nfunction Dr(t) {\n  if (!y || !t)\n    return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.paddingTop) + parseFloat(e.paddingBottom) || 0;\n}\nfunction Ir(t) {\n  if (!y || !t)\n    return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.marginLeft) + parseFloat(e.marginRight) || 0;\n}\nfunction Lr(t) {\n  if (!y || !t)\n    return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.marginTop) + parseFloat(e.marginBottom) || 0;\n}\nfunction Hr(t) {\n  if (!y || !t)\n    return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.borderLeftWidth) + parseFloat(e.borderRightWidth) || 0;\n}\nfunction Pr(t) {\n  if (!y || !t)\n    return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.borderTopWidth) + parseFloat(e.borderBottomWidth) || 0;\n}\nfunction Br(t) {\n  if (!y || !t)\n    return 0;\n  const e = document.createRange();\n  e.setStart(t, 0), e.setEnd(t, t.childNodes.length);\n  const n = e.getBoundingClientRect().width, r = rn(t);\n  return n + r;\n}\nfunction Ur(t) {\n  return pe(t, !0) ? `${me(t)}px` : String(t).trim();\n}\nconst on = /[\"'&<>]/;\nfunction Yr(t) {\n  const e = \"\" + t, n = on.exec(e);\n  if (!n)\n    return e;\n  let r = \"\", o, i, s = 0;\n  for (i = n.index; i < e.length; i++) {\n    switch (e.charCodeAt(i)) {\n      case 34:\n        o = \"&quot;\";\n        break;\n      case 38:\n        o = \"&amp;\";\n        break;\n      case 39:\n        o = \"&#39;\";\n        break;\n      case 60:\n        o = \"&lt;\";\n        break;\n      case 62:\n        o = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    s !== i && (r += e.substring(s, i)), s = i + 1, r += o;\n  }\n  return s !== i ? r + e.substring(s, i) : r;\n}\nfunction Wr() {\n  const t = /* @__PURE__ */ new Map();\n  return {\n    on(e, n) {\n      const r = t.get(e);\n      (r == null ? void 0 : r.add(n)) || t.set(e, /* @__PURE__ */ new Set([n]));\n    },\n    off(e, n) {\n      const r = t.get(e);\n      r && r.delete(n);\n    },\n    clear(e) {\n      const n = t.get(e);\n      n && n.clear();\n    },\n    clearAll() {\n      t.clear();\n    },\n    emit(e, ...n) {\n      const r = t.get(e);\n      r && r.forEach((o) => {\n        o(...n);\n      });\n    }\n  };\n}\nfunction lt(t, e, n) {\n  t && !e.has(t) && (n(t), e.add(t));\n}\nconst sn = /* @__PURE__ */ new Set();\nfunction Gr(t, e = console.info) {\n  lt(t, sn, e);\n}\nconst cn = /* @__PURE__ */ new Set();\nfunction zr(t, e = console.warn) {\n  lt(t, cn, e);\n}\nconst an = /* @__PURE__ */ new Set();\nfunction qr(t, e = console.warn) {\n  lt(t, an, e);\n}\nconst dt = y ? requestAnimationFrame : (t) => {\n  setTimeout(t, 16);\n};\nfunction jr(t, e = 16) {\n  if (typeof t != \"function\")\n    return ot;\n  const n = (...i) => {\n    t(...i);\n  };\n  if (e <= 0)\n    return Xt(n);\n  let r = 0, o;\n  return function(...i) {\n    const s = Date.now(), c = s - r;\n    clearTimeout(o), c >= e ? (r = s, n(...i)) : o = setTimeout(\n      () => {\n        r = Date.now(), n(...i);\n      },\n      Math.max(0, e - c)\n    );\n  };\n}\nfunction Kr(t, e = 100) {\n  if (typeof t != \"function\")\n    return ot;\n  const n = (...o) => {\n    t(...o);\n  };\n  if (e <= 0)\n    return Xt(n);\n  let r;\n  return function(...o) {\n    clearTimeout(r), r = setTimeout(() => {\n      n(...o);\n    }, e);\n  };\n}\nfunction Xt(t) {\n  if (typeof t != \"function\")\n    return t;\n  let e = !1, n, r;\n  return function(...o) {\n    return n = o, e || (e = !0, r = Promise.resolve().then(() => (e = !1, r = void 0, t(...n)))), r;\n  };\n}\nfunction Qr(t) {\n  if (typeof t != \"function\")\n    return t;\n  let e = !1, n, r;\n  return function(...o) {\n    return n = o, e || (e = !0, r = new Promise(\n      (i) => dt(() => {\n        e = !1, r = void 0, i(t(...n));\n      })\n    )), r;\n  };\n}\nconst x = /* @__PURE__ */ new Set(), Zt = /* @__PURE__ */ new WeakMap();\nfunction fn() {\n  x.forEach((t) => {\n    t(...Zt.get(t));\n  }), x.clear();\n}\nfunction Xr(t, ...e) {\n  if (typeof t != \"function\")\n    return t;\n  Zt.set(t, e), !x.has(t) && (x.add(t), x.size === 1 && Promise.resolve().then(fn));\n}\nconst D = /* @__PURE__ */ new Set(), Vt = /* @__PURE__ */ new WeakMap();\nfunction un() {\n  D.forEach((t) => {\n    t(...Vt.get(t));\n  }), D.clear();\n}\nfunction Zr(t, ...e) {\n  if (typeof t != \"function\")\n    return t;\n  Vt.set(t, e), !D.has(t) && (D.add(t), D.size === 1 && dt(un));\n}\nasync function Vr(t, e, n) {\n  const r = [], o = [];\n  for (const i of e) {\n    const s = Promise.resolve().then(() => n(i, e));\n    if (r.push(s), t <= e.length) {\n      const c = s.then(() => o.splice(o.indexOf(c), 1));\n      o.push(c), o.length >= t && await Promise.race(o);\n    }\n  }\n  return Promise.all(r);\n}\nlet et = null;\nfunction vr() {\n  if (!y)\n    return !0;\n  if (et === null) {\n    const t = document.createElement(\"div\");\n    t.style.display = \"flex\", t.style.flexDirection = \"column\", t.style.rowGap = \"1px\", t.appendChild(document.createElement(\"div\")), t.appendChild(document.createElement(\"div\")), document.body.appendChild(t), et = t.scrollHeight === 1, document.body.removeChild(t);\n  }\n  return et;\n}\nlet nt = null;\nfunction Jr() {\n  return y ? (nt === null && (nt = \"loading\" in document.createElement(\"img\")), nt) : !0;\n}\nfunction to(t) {\n  return Array.isArray(t) ? t : [t];\n}\nfunction eo(t, ...e) {\n  return Ft(t) ? t(...e) : t;\n}\nfunction no(t) {\n  return t.replace(/[\\\\/]+/g, \"/\");\n}\nfunction ro(t) {\n  return t[t.length - 1];\n}\nfunction oo(t, e, n = (o) => o, r = !1) {\n  const o = r ? /* @__PURE__ */ new Map() : {};\n  if (!w(e))\n    return o;\n  const i = r ? (c, a) => o.set(c, a) : (c, a) => o[c] = a, s = Ft(e) ? e : (c) => c[e];\n  return t.forEach((c) => {\n    const a = s(c);\n    w(a) && i(a, n(c));\n  }), o;\n}\nfunction io(t, e, n = !1) {\n  let r = -1;\n  return n || typeof e != \"function\" ? r = t.findIndex((o) => o === e) : r = t.findIndex(e), ~r ? t.splice(r, 1)[0] : null;\n}\nfunction so(t, e = []) {\n  (typeof e == \"string\" || typeof e == \"function\") && (e = [e]);\n  const n = e.length, r = {};\n  for (const o of t) {\n    let i;\n    for (let s = 0; s < n; ++s) {\n      const c = s === n - 1, a = e[s], f = typeof a == \"function\" ? a(o) : o[a];\n      i ? (i[f] || (i[f] = c ? [] : {}), i = i[f]) : (r[f] || (r[f] = c ? [] : {}), i = r[f]);\n    }\n    i.push(o);\n  }\n  return r;\n}\nfunction co(t, e = {}) {\n  const {\n    keyField: n = \"id\",\n    childField: r = \"children\",\n    parentField: o = \"parent\",\n    rootId: i = null\n  } = e, s = w(i) && i !== \"\", c = [], a = /* @__PURE__ */ new Map();\n  for (let f = 0, u = t.length; f < u; ++f) {\n    const d = t[f], g = d[n];\n    if (!(s ? g === i : !w(g)))\n      if (a.has(g) ? d[r] = a.get(g) : (d[r] = [], a.set(g, d[r])), d[o] && (!s || d[o] !== i)) {\n        const l = d[o];\n        a.has(l) || a.set(l, []), a.get(l).push(d);\n      } else\n        c.push(d);\n  }\n  return c;\n}\nfunction ao(t, e = {}) {\n  const {\n    keyField: n = \"id\",\n    childField: r = \"children\",\n    parentField: o = \"parent\",\n    rootId: i = null,\n    depthFirst: s = !1,\n    injectId: c = !0,\n    buildId: a = (m) => m,\n    filter: f = oe,\n    cascaded: u = !1,\n    forceInject: d = !1\n  } = e;\n  let g = 1;\n  const l = w(i) && i !== \"\", p = [], b = [...t];\n  for (; b.length; ) {\n    const m = b.shift(), V = m[r], v = Array.isArray(V) && V.length ? V : [];\n    c && (d || !m[n]) && (m[n] = a(g++));\n    const vt = m[n];\n    c && o && (l ? m[o] === i : !m[o]) && (m[o] = i);\n    const ht = f(m);\n    if (ht && p.push(m), ht || !u) {\n      for (let J = 0, Jt = v.length; J < Jt; ++J) {\n        const gt = v[J];\n        c && o && (gt[o] = vt), !s && b.push(gt);\n      }\n      s && b.unshift(...v);\n    }\n  }\n  return p;\n}\nfunction fo(t, e, n = {}) {\n  const { childField: r = \"children\", depthFirst: o = !1 } = n, i = [...t.map((s) => ({ item: s, depth: 0, parent: null }))];\n  for (; i.length; ) {\n    const { item: s, depth: c, parent: a } = i.shift(), f = s[r];\n    e(s, c, a), W(f) && i[o ? \"unshift\" : \"push\"](\n      ...Array.from(f).map((u) => ({ item: u, depth: c + 1, parent: s }))\n    );\n  }\n}\nfunction uo(t, e, n = {}) {\n  const { childField: r = \"children\", depthFirst: o = !1, clearChildren: i = !0 } = n, s = [], c = [...t.map((a) => ({ item: a, depth: 0, parent: null, result: s }))];\n  for (; c.length; ) {\n    const { item: a, depth: f, parent: u, result: d } = c.shift(), g = a[r], l = e(a, f, u) ?? {};\n    i && (l[r] = []), d.push(l), W(g) && Array.from(g).length && (l[r] = [], c[o ? \"unshift\" : \"push\"](\n      ...Array.from(g).map((b) => ({\n        item: b,\n        depth: f + 1,\n        parent: a,\n        result: l[r]\n      }))\n    ));\n  }\n  return s;\n}\nfunction lo(t, e, n = {}) {\n  const {\n    childField: r = \"children\",\n    leafOnly: o = !1,\n    isLeaf: i = (c) => !W(c[r])\n  } = n, s = (c, a, f) => c.map((u) => ({ ...u })).filter((u) => {\n    const d = u[r], g = i(u), l = W(d) && Array.from(d);\n    if (o && !g) {\n      if (l && l.length) {\n        const b = s(l, a + 1, u);\n        return u[r] = b, !!b.length;\n      }\n      return !1;\n    }\n    const p = e(u, a, f);\n    if (g)\n      return p;\n    if (!o && p)\n      return !0;\n    if (l && l.length) {\n      const b = s(l, a + 1, u);\n      return u[r] = b, !!b.length;\n    }\n    return p;\n  });\n  return s(t, 0, null);\n}\nconst Nt = (t, e) => Number.isNaN(Number(t) - Number(e)) ? String(t).localeCompare(e) : t - e;\nfunction ho(t, e) {\n  if (!t.sort || Y(e) && !e.key || !e.length)\n    return t;\n  const n = Array.from(t);\n  Array.isArray(e) || (e = [e]);\n  const r = e.map(\n    (o) => typeof o == \"string\" ? {\n      key: o,\n      method: Nt,\n      type: \"asc\"\n    } : o\n  ).map((o) => (typeof o.accessor != \"function\" && (o.accessor = (i) => i[o.key]), typeof o.method != \"function\" && (o.method = Nt), o.params = Array.isArray(o.params) ? o.params : [], o));\n  return n.sort((o, i) => {\n    let s = 0;\n    for (const c of r) {\n      const { method: a, type: f, accessor: u, params: d } = c, g = f === \"desc\", l = a(u(o, ...d), u(i, ...d));\n      if (s = g ? -l : l, s)\n        break;\n    }\n    return s;\n  }), n;\n}\nfunction go(t, e, n = !0) {\n  t = n ? je(t) : t;\n  const r = [\n    {\n      source: t,\n      target: e\n    }\n  ];\n  for (; r.length; ) {\n    const { source: o, target: i } = r.pop();\n    Object.keys(i).forEach((s) => {\n      Y(i[s]) ? (Y(o[s]) || (o[s] = {}), r.push({\n        source: o[s],\n        target: i[s]\n      })) : Array.isArray(i[s]) ? (Array.isArray(o[s]) || (o[s] = []), r.push({\n        source: o[s],\n        target: i[s]\n      })) : o[s] = i[s];\n    });\n  }\n  return t;\n}\nfunction po(t) {\n  t = Array.from(t);\n  let e = !1;\n  const n = () => {\n    var r;\n    e || ((r = t.shift()) == null || r(), t.length && dt(n));\n  };\n  return n(), () => e = !0;\n}\nfunction ln(t) {\n  const e = t.match(/[A-Z]+/);\n  return e && e[0] === t;\n}\nconst dn = /\\B([A-Z])(?=[^A-Z_-])/g;\nfunction mo(t) {\n  return t.replace(dn, \"-$1\").toLowerCase();\n}\nfunction hn(t) {\n  return t = t.trim().replace(/\\s+/g, \"-\"), t = t.replace(/-+(\\w)/g, (e, n) => n ? n.toUpperCase() : \"\"), (t.charAt(0).toLocaleUpperCase() + t.slice(1)).replace(\n    /[^\\w]/g,\n    \"\"\n  );\n}\nfunction bo(t) {\n  const e = hn(t);\n  return ln(e) ? e.toLocaleLowerCase() : e.charAt(0).toLowerCase() + e.slice(1);\n}\nexport {\n  _r as CLICK_TYPE,\n  fe as COLOR_NAMES,\n  zt as DAY_ON_HOURS,\n  ir as DAY_ON_MILLISECONDS,\n  Ee as DAY_ON_MILLS,\n  we as DAY_ON_MINUTES,\n  qt as DAY_ON_SECONDS,\n  Ct as HEX_REG_3,\n  xt as HEX_REG_4,\n  Dt as HEX_REG_6,\n  It as HEX_REG_8,\n  or as HOUR_ON_MILLISECONDS,\n  Se as HOUR_ON_MILLS,\n  X as HOUR_ON_MINUTES,\n  Gt as HOUR_ON_SECONDS,\n  Rt as HSLA_REG,\n  $t as HSL_REG,\n  kt as HSVA_REG,\n  _t as HSV_REG,\n  rr as MINUTE_ON_MILLISECONDS,\n  Me as MINUTE_ON_MILLS,\n  C as MINUTE_ON_SECONDS,\n  G as NAMED_COLORS,\n  Kt as QUARTER_ON_MONTHS,\n  Ot as RGBA_REG,\n  Tt as RGB_REG,\n  A as SECOND_ON_MILLISECONDS,\n  ye as SECOND_ON_MILLS,\n  Xe as USE_TOUCH,\n  ct as WEEK_ON_DAYS,\n  Ne as WEEK_ON_HOURS,\n  sr as WEEK_ON_MILLISECONDS,\n  Fe as WEEK_ON_MILLS,\n  Ae as WEEK_ON_MINUTES,\n  jt as WEEK_ON_SECONDS,\n  Oe as YEAR_ON_MONTHS,\n  Te as YEAR_ON_QUARTERS,\n  at as addDays,\n  ur as addHalfDays,\n  Ie as addHours,\n  Ce as addMilliseconds,\n  De as addMinutes,\n  ft as addMonths,\n  dr as addQuarters,\n  xe as addSeconds,\n  lr as addWeeks,\n  hr as addYears,\n  Un as adjustAlpha,\n  Zn as boundRange,\n  co as buildTree,\n  eo as callIfFunc,\n  Ge as compareAsc,\n  k as compareDesc,\n  Qt as contains,\n  qn as createBITree,\n  Wr as createEventEmitter,\n  Kr as debounce,\n  Qr as debounceFrame,\n  Xt as debounceMinor,\n  Dn as decide,\n  E as decimalLength,\n  je as deepClone,\n  Rr as destroyObject,\n  Ue as differenceDays,\n  ze as differenceFullDays,\n  Fr as differenceFullHours,\n  Ar as differenceFullMinutes,\n  qe as differenceFullMonths,\n  Or as differenceFullQuarters,\n  Nr as differenceFullSeconds,\n  Tr as differenceFullWeeks,\n  $r as differenceFullYears,\n  Be as differenceHours,\n  ut as differenceMilliseconds,\n  Pe as differenceMinutes,\n  Ye as differenceMonths,\n  Er as differenceQuarters,\n  He as differenceSeconds,\n  wr as differenceWeeks,\n  We as differenceYears,\n  jn as digitLength,\n  kr as dispatchEvent,\n  nr as divide,\n  N as doubleDigits,\n  br as endOfDay,\n  to as ensureArray,\n  qr as errorOnce,\n  Yr as escapeHtml,\n  lo as filterTree,\n  ao as flatTree,\n  cr as format,\n  vn as formatByteSize,\n  fr as getChineseWeek,\n  ro as getLast,\n  mr as getLastSunday,\n  rt as getQuarter,\n  Br as getRangeWidth,\n  ar as getTime,\n  ie as getType,\n  Hr as getXBorder,\n  Ir as getXMargin,\n  rn as getXPadding,\n  Pr as getYBorder,\n  Lr as getYMargin,\n  Dr as getYPadding,\n  so as groupByProps,\n  pn as has,\n  le as hslToHsv,\n  Lt as hslToRgb,\n  Pn as hsvToHsl,\n  de as hsvToRgb,\n  Gr as infoOnce,\n  B as is,\n  Nn as isArray,\n  En as isBigInt,\n  yn as isBoolean,\n  y as isClient,\n  Ln as isColor,\n  On as isDate,\n  w as isDefined,\n  nn as isDisabled,\n  _n as isElement,\n  Rn as isEmpty,\n  Sn as isFalse,\n  Cr as isFocusIn,\n  Ft as isFunction,\n  tn as isHidden,\n  gn as isIOS,\n  W as isIterable,\n  Le as isLeapYear,\n  Tn as isMap,\n  re as isNaN,\n  ne as isNull,\n  mn as isNumber,\n  Y as isObject,\n  An as isPromise,\n  $n as isRegExp,\n  Fn as isSet,\n  bn as isString,\n  wn as isSymbol,\n  Mn as isTrue,\n  pe as isValidNumber,\n  en as isVisible,\n  Vn as leaveNumber,\n  oo as listToMap,\n  uo as mapTree,\n  go as mergeObjects,\n  er as minus,\n  Bn as mixColor,\n  Qn as multipleFixed,\n  Zr as nextFrameOnce,\n  Xr as nextTickOnce,\n  ot as noop,\n  R as normalizeAlpha,\n  z as normalizeHsl,\n  q as normalizeHsv,\n  no as normalizePath,\n  _ as normalizeRgb,\n  ge as numberRE,\n  be as padStartZeros,\n  Hn as parseColor,\n  T as parseColorToRgba,\n  ue as parseStringColor,\n  tr as plus,\n  Je as queryAll,\n  xr as queryTabables,\n  dt as raf,\n  Jn as random,\n  Yn as randomColor,\n  Wn as randomHardColor,\n  Bt as randomPreferColor,\n  Gn as randomSoftColor,\n  xn as randomString,\n  Cn as range,\n  gr as rangeDate,\n  pr as rangeMonth,\n  io as removeArrayItem,\n  it as rgbToHex,\n  Ht as rgbToHsl,\n  Pt as rgbToHsv,\n  st as rgbaToHex,\n  Xn as round,\n  Vr as runParallel,\n  po as runQueueFrame,\n  Kn as segmentNumber,\n  ho as sortByProps,\n  wt as startOfDay,\n  St as startOfHour,\n  Mt as startOfMinute,\n  yr as startOfMonth,\n  Mr as startOfQuarter,\n  yt as startOfSecond,\n  Et as startOfWeek,\n  Sr as startOfYear,\n  vr as supportFlexGap,\n  Jr as supportImgLoading,\n  jr as throttle,\n  P as times,\n  bo as toCamelCase,\n  hn as toCapitalCase,\n  Ur as toCssSize,\n  h as toDate,\n  kn as toFalse,\n  Yt as toFixed,\n  zn as toGrayScale,\n  mo as toKebabCase,\n  me as toNumber,\n  Wt as toPrecision,\n  oe as toTrue,\n  oo as transformListToMap,\n  co as transformTree,\n  fo as walkTree,\n  zr as warnOnce,\n  In as writeClipboard\n};\n//# sourceMappingURL=index.mjs.map\n", "import { getCurrentScope, onScopeDispose, unref, watch } from 'vue'\n\nimport { noop } from '@vexip-ui/utils'\n\nimport type { MaybeRef } from 'vue'\n\nexport function useListener<E = Event>(\n  target: MaybeRef<EventTarget | null | undefined>,\n  event: string,\n  listener: (event: E) => any,\n  options?: AddEventListenerOptions | boolean\n) {\n  if (!target) {\n    return noop\n  }\n\n  let remove = noop\n\n  const stopWatch = watch(\n    () => unref(target),\n    el => {\n      remove()\n\n      if (!el) {\n        return\n      }\n\n      el.addEventListener(event, listener as any, options)\n\n      remove = () => {\n        el.removeEventListener(event, listener as any, options)\n        remove = noop\n      }\n    },\n    { immediate: true, flush: 'post' }\n  )\n\n  const stop = () => {\n    stopWatch()\n    remove()\n  }\n\n  getCurrentScope() && onScopeDispose(stop)\n\n  return stop\n}\n", "import { getCurrentScope, onScopeDispose, ref, unref, watch } from 'vue'\n\nimport { CLICK_TYPE, dispatchEvent, isClient, noop } from '@vexip-ui/utils'\nimport { useListener } from './listener'\n\nimport type { Ref } from 'vue'\nimport type { TransferNode } from '@vexip-ui/utils'\n\nexport const CLICK_OUTSIDE = 'clickoutside'\n\nconst elements = new Set<TransferNode>()\n\nif (isClient) {\n  document.addEventListener(\n    CLICK_TYPE,\n    (event: Event) => {\n      const target = event.target as Node | null\n      const path = event.composedPath && event.composedPath()\n\n      elements.forEach(el => {\n        if (\n          el !== target &&\n          (path ? !path.includes(el) : !el.contains(target)) &&\n          (!el.__transferElement ||\n            (el.__transferElement !== target && !el.__transferElement.contains(target)))\n        ) {\n          dispatchEvent(el, { type: CLICK_OUTSIDE })\n        }\n      })\n    },\n    true\n  )\n}\n\n/**\n * 创建一个可以添加 clickoutside 事件的元素 Ref\n *\n * @param handler 事件的回调方法\n * @param target 需要处理的元素 ref，可不传\n */\nexport function useClickOutside(\n  handler: () => void,\n  target: Ref<HTMLElement | null | undefined> = ref(null)\n) {\n  let remove = noop\n\n  const stopWatch = watch(\n    () => unref(target),\n    el => {\n      remove()\n\n      if (!el) {\n        return\n      }\n\n      elements.add(el)\n\n      remove = () => {\n        elements.delete(el)\n        remove = noop\n      }\n    },\n    { immediate: true, flush: 'post' }\n  )\n\n  const stop = () => {\n    stopWatch()\n    remove()\n  }\n\n  getCurrentScope() && onScopeDispose(stop)\n  useListener(target, CLICK_OUTSIDE, handler)\n\n  return target\n}\n", "import { nextTick, onBeforeUnmount, onMounted, ref } from 'vue'\n\nimport { noop } from '@vexip-ui/utils'\n\nimport type { Ref } from 'vue'\n\n/**\n * 创建一个观察了最近的上级元素 display 变化的元素 Ref\n *\n * @param displayInit 元素初次显示后执行的回调\n * @returns 观察了 display 变化的元素 Ref\n */\nexport function useDisplay(\n  displayInit = noop,\n  element: Ref<HTMLElement | null | undefined> = ref(null)\n) {\n  let observer: MutationObserver | null\n\n  onMounted(() => {\n    nextTick(() => {\n      const hiddenParentNode = queryOutsideHiddenElement(element.value)\n\n      if (hiddenParentNode) {\n        observer = new MutationObserver(() => {\n          if (hiddenParentNode.style.display !== 'none') {\n            if (typeof displayInit === 'function') {\n              displayInit()\n            }\n\n            observer?.disconnect()\n            observer = null\n          }\n        })\n\n        observer.observe(hiddenParentNode, {\n          attributes: true,\n          childList: true,\n          characterData: true,\n          attributeFilter: ['style']\n        })\n      } else {\n        typeof displayInit === 'function' && displayInit()\n      }\n    })\n  })\n\n  onBeforeUnmount(() => {\n    observer?.disconnect()\n    observer = null\n  })\n\n  return element\n}\n\nexport function queryOutsideHiddenElement(el?: Element | null) {\n  if (el) {\n    let parentElement = el.parentElement\n\n    while (parentElement && parentElement !== document.body) {\n      if (parentElement.style.display === 'none') {\n        return parentElement\n      }\n\n      parentElement = parentElement.parentElement\n    }\n  }\n\n  return null\n}\n\nexport function isHiddenElement(el?: HTMLElement | null) {\n  if (el?.style.display !== 'none') {\n    return !!queryOutsideHiddenElement(el)\n  }\n\n  return true\n}\n", "import {\n  Comment,\n  Fragment,\n  createTextVNode,\n  isVNode,\n  readonly,\n  ref,\n  renderSlot,\n  unref,\n  watch\n} from 'vue'\n\nimport { ensureArray, isClient, noop } from '@vexip-ui/utils'\n\nimport type {\n  ComponentPublicInstance,\n  MaybeRef,\n  Slots,\n  VNode,\n  VNodeChild,\n  VNodeNormalizedChildren\n} from 'vue'\nimport type { MaybeElement, MaybeInstance } from './types'\n\nexport function createSlotRender(\n  slots: Slots,\n  names: string[]\n): ((params?: any) => VNodeChild) | null\nexport function createSlotRender(\n  slots: Slots,\n  names: string[],\n  fallback: (params?: any) => VNodeChild\n): (params?: any) => VNodeChild\nexport function createSlotRender(\n  slots: Slots,\n  names: string[],\n  fallback?: (params?: any) => VNodeChild\n) {\n  for (const name of names) {\n    if (slots[name]) {\n      return (params: any) =>\n        renderSlot(slots, name, params, () => {\n          const vnodes = fallback?.(params)\n\n          return vnodes ? ensureArray(vnodes) : []\n        })\n    }\n  }\n\n  return fallback || null\n}\n\nexport function flatVNodes(children: VNodeNormalizedChildren) {\n  const result: VNode[] = []\n  const loop = Array.isArray(children) ? [...children] : []\n\n  while (loop.length) {\n    const vnode = loop.shift()!\n\n    if (vnode === null) continue\n\n    if (Array.isArray(vnode)) {\n      loop.unshift(...vnode)\n    }\n\n    if (\n      typeof vnode !== 'string' &&\n      typeof vnode !== 'number' &&\n      (!isVNode(vnode) || vnode.type === Comment)\n    ) {\n      continue\n    }\n\n    if (typeof vnode === 'string' || typeof vnode === 'number') {\n      result.push(createTextVNode(String(vnode)))\n    } else if (vnode.type === Fragment && Array.isArray(vnode.children)) {\n      loop.unshift(vnode.children)\n    } else {\n      result.push(vnode)\n    }\n  }\n\n  return result\n}\n\nexport function unrefElement<T extends string | MaybeInstance = string | MaybeInstance>(\n  ref: MaybeRef<T>\n): T extends string | ComponentPublicInstance ? MaybeElement : T {\n  const plain = unref(ref)\n\n  if (typeof plain === 'string') {\n    return isClient ? document.querySelector(plain) : (null as any)\n  }\n\n  return (plain as ComponentPublicInstance)?.$el ?? plain\n}\n\nexport function proxyExposed<T>(vnode: VNode): T {\n  return new Proxy({} as any, {\n    get(_, key) {\n      if (!vnode.component) return undefined\n\n      return (\n        (vnode.component.proxy as any)?.[key] ??\n        (vnode.component.exposeProxy as any)?.[key] ??\n        (vnode.component.exposed as any)?.[key]\n      )\n    }\n  }) as T\n}\n\nexport function watchPauseable(...args: Parameters<typeof watch>) {\n  const active = ref(true)\n  const handle = args[1] || noop\n\n  function pause() {\n    active.value = false\n  }\n\n  function resume() {\n    active.value = true\n  }\n\n  const stop = watch(\n    args[0],\n    (...callbackArgs) =>\n      new Promise<void>((resolve, reject) => {\n        if (active.value) {\n          Promise.resolve(handle(...callbackArgs))\n            .then(resolve)\n            .catch(reject)\n        }\n      }),\n    args[2]\n  )\n\n  return { active: readonly(active), pause, resume, stop }\n}\n", "import { computed, getCurrentScope, isRef, onScopeDispose, ref, watch } from 'vue'\n\nimport { isClient, noop } from '@vexip-ui/utils'\nimport { unrefElement } from './shared/utils'\n\nimport type { ComputedRef, MaybeRef, Ref } from 'vue'\nimport type { MaybeInstance } from './shared/types'\n\nexport interface UseFullScreenResult {\n  target: Ref<MaybeInstance>,\n  supported: boolean,\n  full: ComputedRef<boolean>,\n  enter: (force?: boolean) => Promise<boolean>,\n  exit: (force?: boolean) => Promise<boolean>,\n  toggle: (force?: boolean) => Promise<boolean>\n}\n\ntype PropertiesMap = [\n  'requestFullscreen',\n  'exitFullscreen',\n  'fullscreenElement',\n  'fullscreenEnabled',\n  'fullscreenchange',\n  'fullscreenerror'\n]\n\nconst functionsMap = [\n  [\n    'requestFullscreen',\n    'exitFullscreen',\n    'fullscreenElement',\n    'fullscreenEnabled',\n    'fullscreenchange',\n    'fullscreenerror'\n  ],\n  // New WebKit\n  [\n    'webkitRequestFullscreen',\n    'webkitExitFullscreen',\n    'webkitFullscreenElement',\n    'webkitFullscreenEnabled',\n    'webkitfullscreenchange',\n    'webkitfullscreenerror'\n  ],\n  // Old WebKit\n  [\n    'webkitRequestFullScreen',\n    'webkitCancelFullScreen',\n    'webkitCurrentFullScreenElement',\n    'webkitCancelFullScreen',\n    'webkitfullscreenchange',\n    'webkitfullscreenerror'\n  ],\n  [\n    'mozRequestFullScreen',\n    'mozCancelFullScreen',\n    'mozFullScreenElement',\n    'mozFullScreenEnabled',\n    'mozfullscreenchange',\n    'mozfullscreenerror'\n  ],\n  [\n    'msRequestFullscreen',\n    'msExitFullscreen',\n    'msFullscreenElement',\n    'msFullscreenEnabled',\n    'MSFullscreenChange',\n    'MSFullscreenError'\n  ]\n] as PropertiesMap[]\n\nlet map!: PropertiesMap\n\nif (isClient) {\n  for (const m of functionsMap) {\n    if (m[1] in document) {\n      map = m\n      break\n    }\n  }\n}\n\nconst supported = !!map\nconst notSupportedResult = {\n  supported,\n  full: computed(() => false),\n  enter: noop,\n  exit: noop,\n  toggle: noop\n}\n\nconst states = new Set<Ref<boolean>>()\nconst subscriptions = new WeakMap<Element, Ref<boolean>>()\n\nif (isClient && map) {\n  const ELEMENT = map[2]\n  const EVENT = map[4]\n\n  document.addEventListener(\n    EVENT,\n    () => {\n      debugger\n      states.forEach(state => {\n        state.value = false\n      })\n\n      if (document[ELEMENT]) {\n        const full = subscriptions.get(document[ELEMENT])\n\n        if (full) {\n          full.value = true\n        }\n      }\n    },\n    false\n  )\n}\n\nexport function useFullScreen(target: MaybeRef<MaybeInstance> = ref(null)): UseFullScreenResult {\n  const targetRef = computed({\n    get: () => unrefElement(target),\n    set: el => {\n      if (isRef(target)) {\n        target.value = el\n      }\n    }\n  })\n\n  if (!isClient || !supported) {\n    return { ...notSupportedResult, target: targetRef }\n  }\n\n  const [REQUEST, EXIT, ELEMENT] = map\n  const full = ref(false)\n\n  watch(\n    () => unrefElement(target),\n    (el, old) => {\n      old && subscriptions.delete(old)\n      el && subscriptions.set(el, full)\n    },\n    { immediate: true, flush: 'post' }\n  )\n\n  states.add(full)\n\n  if (getCurrentScope()) {\n    onScopeDispose(exit)\n  }\n\n  async function enter(force = false) {\n    await exit()\n\n    const el = unrefElement(target)\n\n    if (el) {\n      if (force || !document[ELEMENT]) {\n        debugger\n        await el[REQUEST]()\n        full.value = true\n\n        return document[ELEMENT] === el\n      }\n    }\n\n    return false\n  }\n\n  async function exit(force = false) {\n    const el = unrefElement(target)\n\n    if (force || (document[ELEMENT] && document[ELEMENT] === el)) {\n      debugger\n      await document[EXIT]()\n      full.value = false\n\n      return document[ELEMENT] !== el\n    }\n\n    return false\n  }\n\n  async function toggle(force = false) {\n    return full.value ? await exit(force) : await enter(force)\n  }\n\n  return {\n    supported,\n    target: targetRef,\n    full: computed(() => full.value),\n    enter,\n    exit,\n    toggle\n  }\n}\n", "import { ref } from 'vue'\n\nimport { useListener } from './listener'\n\nimport type { Ref } from 'vue'\n\nexport function useHover(wrapper: Ref<HTMLElement | null | undefined> = ref(null)) {\n  const isHover = ref(false)\n\n  useListener(wrapper, 'mouseenter', enterWrapper)\n  useListener(wrapper, 'mouseleave', leaveWrapper)\n\n  function enterWrapper() {\n    isHover.value = true\n  }\n\n  function leaveWrapper() {\n    isHover.value = false\n  }\n\n  return { wrapper, isHover }\n}\n", "import { getCurrentScope, onScopeDispose, ref, unref, watch } from 'vue'\n\nimport { ensureArray, isClient, noop, toNumber } from '@vexip-ui/utils'\n\nimport type { Ref } from 'vue'\n\nexport type IntersectionHandler = (entry: IntersectionObserverEntry) => any\nexport type UseIntersectionOptions = IntersectionObserverInit & {\n  /**\n   * 元素交叉状态变化时的回调方法\n   */\n  handler: IntersectionHandler,\n  /**\n   * 作用的目标元素的 Ref\n   */\n  target?: Ref<HTMLElement | null | undefined>\n}\n\nconst observerCache = new WeakMap<\n  Element | Document,\n  Map<\n    string,\n    Map<\n      string,\n      { ob: IntersectionObserver, count: number, handlers: WeakMap<Element, IntersectionHandler> }\n    >\n  >\n>()\n\nconst spaceRE = /\\s+/g\nconst unitRE = /(px|%)$/\n\nexport function useIntersection(options: UseIntersectionOptions) {\n  const target = options.target || ref(null)\n\n  if (!isClient) {\n    return { target, disconnect: noop }\n  }\n\n  const { handler } = options\n\n  let root = options.root ?? document\n\n  const threshold = ensureArray(options.threshold || 0).join() || '0'\n  const margin = normalizeMargin(options.rootMargin)\n\n  if (!observerCache.has(root)) {\n    observerCache.set(root, new Map())\n  }\n\n  const thresholdCache = observerCache.get(root)!\n\n  if (!thresholdCache.has(threshold)) {\n    thresholdCache.set(threshold, new Map())\n  }\n\n  const marginCache = thresholdCache.get(threshold)!\n\n  if (!marginCache.has(margin)) {\n    marginCache.set(margin, {\n      ob: new IntersectionObserver(handleIntersect, { ...options, rootMargin: margin }),\n      count: 0,\n      handlers: new WeakMap<Element, IntersectionHandler>()\n    })\n  }\n\n  let state = marginCache.get(margin)\n  let { ob: observer, handlers } = state!\n\n  let remove = noop\n\n  const stopWatch = watch(\n    () => unref(target),\n    el => {\n      remove()\n\n      if (!el || !observer) {\n        return\n      }\n\n      handlers.set(el, handler)\n      observer.observe(el)\n      state && state.count++\n\n      remove = () => {\n        observer.unobserve(el)\n        handlers.delete(el)\n        state && state.count--\n        remove = noop\n      }\n    },\n    { immediate: true, flush: 'post' }\n  )\n\n  getCurrentScope() && onScopeDispose(disconnect)\n\n  function normalizeMargin(margin?: string) {\n    if (!margin || !margin.trim()) return '_'\n\n    const parts = margin.trim().split(spaceRE, 4)\n    parts.length = 4\n\n    for (let i = 0; i < 4; ++i) {\n      const part = parts[i]\n\n      parts[i] = unitRE.test(part) ? part : `${toNumber(part)}px`\n    }\n\n    return parts.join(' ')\n  }\n\n  function handleIntersect(entries: IntersectionObserverEntry[]) {\n    for (let i = 0, len = entries.length; i < len; ++i) {\n      const entry = entries[i]\n      const handler = handlers.get(entry.target)\n\n      if (typeof handler === 'function') {\n        handler(entry)\n      }\n    }\n  }\n\n  function disconnect() {\n    stopWatch()\n    remove()\n\n    if (!state) return\n\n    if (state.count <= 0) {\n      marginCache.delete(margin)\n\n      if (!marginCache.size) {\n        thresholdCache.delete(threshold)\n\n        if (!thresholdCache.size) {\n          observerCache.delete(root)\n        }\n      }\n    }\n\n    state = undefined\n    observer = undefined!\n    handlers = undefined!\n    root = undefined!\n  }\n\n  return { target, disconnect }\n}\n", "import { customRef } from 'vue'\n\nexport function useManualRef() {\n  const updateSet = new Set<() => void>()\n\n  function manualRef<T>(value: T) {\n    return customRef<T>((track, trigger) => {\n      let origin = value\n\n      const update = () => {\n        if (value !== origin) {\n          origin = value\n          trigger()\n        }\n      }\n\n      return {\n        // eslint-disable-next-line no-sequences\n        get: () => (track(), value),\n        set: newValue => {\n          if (newValue === value) return\n\n          value = newValue\n          updateSet.add(update)\n        }\n      }\n    })\n  }\n\n  function triggerUpdate() {\n    for (const trigger of updateSet) {\n      trigger()\n    }\n\n    updateSet.clear()\n  }\n\n  return { updateSet, manualRef, triggerUpdate }\n}\n", "import { computed, reactive, ref, unref } from 'vue'\n\nimport { noop } from '@vexip-ui/utils'\nimport { useListener } from './listener'\n\nimport type { Ref } from 'vue'\n\nexport type ModifierState = Readonly<\n  Omit<Record<string, boolean>, 'activeKeys'> & {\n    activeKeys: Set<string>,\n    resetAll: () => void\n  }\n>\n\nexport interface UseModifierOptions {\n  /**\n   * 作用的目标元素的 Ref\n   */\n  target?: Ref<HTMLElement | null | undefined>,\n  /**\n   * 配置键名的别名，会与默认别名动态合并\n   */\n  aliasMap?: Record<string, string>,\n  /**\n   * 是否在目标元素失去焦点时重置修饰符\n   *\n   * @default true\n   */\n  autoReset?: boolean,\n  /**\n   * 事件的 capture 选项\n   *\n   * @default false\n   */\n  capture?: boolean,\n  /**\n   * 事件的 passive 选项\n   *\n   * @default true\n   */\n  passive?: boolean,\n  /**\n   * 键按下的事件回调函数\n   */\n  onKeyDown?: (event: KeyboardEvent, modifier: ModifierState) => void,\n  /**\n   * 键抬起的时间回调函数\n   */\n  onKeyUp?: (event: KeyboardEvent, modifier: ModifierState) => void\n}\n\nconst defaultAliasMap: Record<string, string> = {\n  ctrl: 'control',\n  command: 'meta',\n  cmd: 'meta',\n  option: 'alt',\n  up: 'arrowup',\n  down: 'arrowdown',\n  left: 'arrowleft',\n  right: 'arrowright'\n}\n\nconst separatorRE = /[+_-]/\nconst splitRE = /[+_-]/g\n\nconst internalProps = ['activeKeys', 'resetAll']\n\nexport function useModifier(options: UseModifierOptions = {}) {\n  const {\n    autoReset = true,\n    capture = false,\n    passive = true,\n    onKeyDown = noop,\n    onKeyUp = noop\n  } = options\n\n  const target = options.target || ref(null)\n  const aliasMap = { ...defaultAliasMap, ...(options.aliasMap || {}) }\n  const activeKeys = reactive(new Set<string>())\n  const metaDeps = new Set<string>()\n  const modifier: Record<string, any> = reactive({ activeKeys, resetAll })\n\n  function setModifier(key: string, value: boolean) {\n    if (key in modifier) {\n      modifier[key] = value\n    }\n  }\n\n  function updateModifier(event: KeyboardEvent, value: boolean) {\n    const key = event.key?.toLocaleLowerCase()\n    const code = event.code?.toLocaleLowerCase()\n    const keys = [code, key].filter(Boolean)\n\n    for (const key of keys) {\n      activeKeys[value ? 'add' : 'delete'](key)\n      setModifier(key, value)\n    }\n\n    if (!value && key === 'meta') {\n      for (const key of metaDeps) {\n        activeKeys.delete(key)\n        setModifier(key, false)\n      }\n\n      metaDeps.clear()\n    } else if (\n      value &&\n      typeof event.getModifierState === 'function' &&\n      event.getModifierState('Meta')\n    ) {\n      for (const key of [...activeKeys, ...keys]) {\n        metaDeps.add(key)\n      }\n    }\n  }\n\n  function resetAll() {\n    Object.keys(modifier).forEach(key => {\n      modifier[key] = false\n    })\n\n    modifier.activeKeys = activeKeys\n    modifier.resetAll = resetAll\n  }\n\n  const modifierProxy = new Proxy(modifier, {\n    get(target, prop, receiver) {\n      if (typeof prop !== 'string' || internalProps.includes(prop)) {\n        return Reflect.get(target, prop, receiver)\n      }\n\n      prop = prop.toLocaleLowerCase()\n\n      if (prop in aliasMap) {\n        prop = aliasMap[prop]\n      }\n\n      if (!(prop in modifier)) {\n        if (separatorRE.test(prop)) {\n          const keys = prop.split(splitRE).map(key => key.trim())\n\n          modifier[prop] = computed(() => keys.every(key => unref(modifierProxy[key])))\n        } else {\n          modifier[prop] = ref(activeKeys.has(prop))\n        }\n      }\n\n      return unref(Reflect.get(target, prop, receiver))\n    }\n  })\n\n  useListener(\n    target,\n    'keydown',\n    (event: KeyboardEvent) => {\n      updateModifier(event, true)\n      onKeyDown(event, modifierProxy)\n    },\n    { capture, passive }\n  )\n  useListener(\n    target,\n    'keyup',\n    (event: KeyboardEvent) => {\n      updateModifier(event, false)\n      onKeyUp(event, modifierProxy)\n    },\n    { capture, passive }\n  )\n\n  if (autoReset) {\n    useListener(target, 'blur', resetAll, { capture, passive })\n  }\n\n  return { target, modifier: modifierProxy as ModifierState }\n}\n", "import { nextTick, onBeforeUnmount, onMounted, readonly, ref } from 'vue'\n\nexport function useMounted(wait?: 'tick' | 'frame') {\n  const isMounted = ref(false)\n\n  const mount = () => (isMounted.value = true)\n\n  onMounted(() => {\n    if (wait === 'tick') {\n      nextTick(mount)\n    } else if (wait === 'frame') {\n      requestAnimationFrame(mount)\n    } else {\n      mount()\n    }\n  })\n\n  onBeforeUnmount(() => {\n    isMounted.value = false\n  })\n\n  return { isMounted: readonly(isMounted) }\n}\n", "import { computed, isRef, ref } from 'vue'\n\nimport { throttle } from '@vexip-ui/utils'\nimport { useListener } from './listener'\n\nimport type { MaybeRef, Ref } from 'vue'\n\nexport interface MovingState {\n  xStart: number,\n  yStart: number,\n  xEnd: number,\n  yEnd: number,\n  clientX: number,\n  clientY: number,\n  deltaX: number,\n  deltaY: number,\n  lazy: boolean,\n  [custom: string]: unknown\n}\n\nexport interface UseMovingOptions {\n  /**\n   * 作用的目标元素的 Ref\n   */\n  target?: Ref<HTMLElement | null | undefined>,\n  /**\n   * 横向位置的初始值\n   */\n  x?: MaybeRef<number>,\n  /**\n   * 纵向位置的初始值\n   */\n  y?: MaybeRef<number>,\n  /**\n   * 为否为懒加载，开启后会在 End 事件再更新位置状态\n   */\n  lazy?: MaybeRef<boolean>,\n  /**\n   * 事件的 capture 选项\n   *\n   * @default true\n   */\n  capture?: boolean,\n  /**\n   * 是否阻止 MouseDown 事件冒泡和默认行为\n   *\n   * @default true\n   */\n  stopMouse?: boolean,\n  /**\n   * 是否阻止 TouchStart 事件冒泡和默认行为\n   *\n   * @default true\n   */\n  stopTouch?: boolean,\n  /**\n   * 移动开始时的回调函数，返回 false 可以阻止本次移动\n   */\n  onStart?: (state: MovingState, event: PointerEvent) => any,\n  /**\n   * 移动中的回调函数\n   */\n  onMove?: (state: MovingState, event: PointerEvent) => void,\n  /**\n   * 移动结束时的回调函数\n   */\n  onEnd?: (state: MovingState, event: PointerEvent) => void\n}\n\nfunction disableEvent<E extends Event>(event: E) {\n  if (event.cancelable) {\n    event.stopPropagation()\n    event.preventDefault()\n  }\n}\n\nexport function useMoving(options: UseMovingOptions) {\n  const target = options.target || ref(null)\n  const x = isRef(options.x) ? options.x : ref(0)\n  const y = isRef(options.y) ? options.y : ref(0)\n  const lazy = isRef(options.lazy) ? options.lazy : ref(false)\n\n  const { capture = true, stopMouse = true, stopTouch = true } = options\n\n  const moving = ref(false)\n  const internalState: MovingState = {\n    xStart: 0,\n    yStart: 0,\n    xEnd: 0,\n    yEnd: 0,\n    clientX: 0,\n    clientY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    lazy: false\n  }\n\n  let current = 0\n  let record = 0\n\n  const throttleMove = throttle((event: PointerEvent) => {\n    if (record < current) return\n\n    updateState(event)\n\n    if (!internalState.lazy) {\n      x.value = internalState.xEnd\n      y.value = internalState.yEnd\n    }\n\n    options.onMove?.(internalState, event)\n  })\n\n  function start(event: PointerEvent) {\n    Object.assign(internalState, {\n      xStart: x.value,\n      yStart: y.value,\n      xEnd: x.value,\n      yEnd: y.value,\n      clientX: event.clientX,\n      clientY: event.clientY,\n      lazy: lazy.value\n    })\n\n    if (options.onStart?.(internalState, event) === false) {\n      return\n    }\n\n    document.addEventListener('pointermove', move, { capture })\n    document.addEventListener('pointerup', end, { capture })\n\n    record = current\n    moving.value = true\n  }\n\n  function move(event: PointerEvent) {\n    disableEvent(event)\n    throttleMove(event)\n  }\n\n  function end(event: PointerEvent) {\n    document.removeEventListener('pointermove', move, { capture })\n    document.removeEventListener('pointerup', end, { capture })\n\n    updateState(event)\n\n    if (internalState.lazy) {\n      x.value = internalState.xEnd\n      y.value = internalState.yEnd\n    }\n\n    moving.value = false\n    ++current\n\n    options.onEnd?.(internalState, event)\n  }\n\n  function updateState(event: PointerEvent) {\n    const { clientX, clientY } = event\n    const { xStart, yStart, clientX: clientXStart, clientY: clientYStart } = internalState\n    const deltaX = clientX - clientXStart\n    const deltaY = clientY - clientYStart\n\n    internalState.deltaX = deltaX\n    internalState.deltaY = deltaY\n    internalState.xEnd = xStart + deltaX\n    internalState.yEnd = yStart + deltaY\n  }\n\n  useListener(target, 'pointerdown', start, { capture })\n\n  stopMouse && useListener(target, 'mousedown', disableEvent, { capture })\n  stopTouch && useListener(target, 'touchstart', disableEvent, { capture })\n\n  return {\n    target,\n    moving: computed(() => moving.value),\n    x,\n    y,\n    lazy\n  }\n}\n", "import { onBeforeUnmount, ref } from 'vue'\n\nimport { throttle } from '@vexip-ui/utils'\n\nimport type { Ref } from 'vue'\n\nexport interface UsePointerOption {\n  /**\n   * 横向位置的初始值\n   */\n  x?: number,\n  /**\n   * 纵向位置的初始值\n   */\n  y?: number,\n  /**\n   * 是否手动停止，默认情况下会在组件的 BeforeUnmount 生命周期注销\n   *\n   * @default false\n   */\n  manualStop?: boolean\n}\n\ninterface PointerState {\n  x: Ref<number>,\n  y: Ref<number>\n}\n\nconst registered = new Set<PointerState>()\nconst record = new Map<'x' | 'y', number>()\n\nrecord.set('x', 0)\nrecord.set('y', 0)\n\nfunction handler(event: PointerEvent) {\n  const { pageX, pageY } = event\n\n  record.set('x', pageX)\n  record.set('y', pageY)\n\n  registered.forEach(state => {\n    state.x.value = pageX\n    state.y.value = pageY\n  })\n}\n\nconst throttleHandler = throttle(handler)\n\nfunction register(state: PointerState) {\n  if (!registered.size && window) {\n    record.set('x', 0)\n    record.set('y', 0)\n    window.addEventListener('pointermove', throttleHandler, { passive: true })\n  }\n\n  registered.add(state)\n}\n\nfunction unregister(state: PointerState) {\n  registered.delete(state)\n\n  if (!registered.size && window) {\n    window.removeEventListener('pointermove', throttleHandler)\n  }\n}\n\nexport function usePointer(options: UsePointerOption = {}) {\n  const x = ref(options.x ?? record.get('x')!)\n  const y = ref(options.y ?? record.get('y')!)\n\n  const state = { x, y }\n\n  register(state)\n\n  if (!options.manualStop) {\n    onBeforeUnmount(() => {\n      unregister(state)\n    })\n  }\n\n  return { ...state, unregister: () => unregister(state) }\n}\n", "const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n", "var resizeObservers = [];\nexport { resizeObservers };\n", "import { resizeObservers } from '../utils/resizeObservers';\nvar hasActiveObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\nexport { hasActiveObservations };\n", "import { resizeObservers } from '../utils/resizeObservers';\nvar hasSkippedObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\nexport { hasSkippedObservations };\n", "var msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\nexport { deliverResizeLoopError };\n", "var ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\nexport { ResizeObserverBoxOptions };\n", "export var freeze = function (obj) { return Object.freeze(obj); };\n", "import { freeze } from './utils/freeze';\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        freeze(this);\n    }\n    return ResizeObserverSize;\n}());\nexport { ResizeObserverSize };\n", "import { freeze } from './utils/freeze';\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return freeze(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\nexport { DOMRectReadOnly };\n", "var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\nexport { isSVG, isHidden, isElement, isReplacedElement };\n", "export var global = typeof window !== 'undefined' ? window : {};\n", "import { ResizeObserverBoxOptions } from '../ResizeObserverBoxOptions';\nimport { ResizeObserverSize } from '../ResizeObserverSize';\nimport { DOMRectReadOnly } from '../DOMRectReadOnly';\nimport { isSVG, isHidden } from '../utils/element';\nimport { freeze } from '../utils/freeze';\nimport { global } from '../utils/global';\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = freeze({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if (isHidden(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = freeze({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\nexport { calculateBoxSize, calculateBoxSizes };\n", "import { calculateBoxSizes } from './algorithms/calculateBoxSize';\nimport { freeze } from './utils/freeze';\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = calculateBoxSizes(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = freeze([boxes.borderBoxSize]);\n        this.contentBoxSize = freeze([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\nexport { ResizeObserverEntry };\n", "import { isHidden } from '../utils/element';\nvar calculateDepthForNode = function (node) {\n    if (isHidden(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\nexport { calculateDepthForNode };\n", "import { resizeObservers } from '../utils/resizeObservers';\nimport { ResizeObserverEntry } from '../ResizeObserverEntry';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nimport { calculateBoxSize } from './calculateBoxSize';\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new ResizeObserverEntry(ot.target);\n            var targetDepth = calculateDepthForNode(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\nexport { broadcastActiveObservations };\n", "import { resizeObservers } from '../utils/resizeObservers';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nvar gatherActiveObservationsAtDepth = function (depth) {\n    resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if (calculateDepthForNode(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\nexport { gatherActiveObservationsAtDepth };\n", "import { hasActiveObservations } from '../algorithms/hasActiveObservations';\nimport { hasSkippedObservations } from '../algorithms/hasSkippedObservations';\nimport { deliverResizeLoopError } from '../algorithms/deliverResizeLoopError';\nimport { broadcastActiveObservations } from '../algorithms/broadcastActiveObservations';\nimport { gatherActiveObservationsAtDepth } from '../algorithms/gatherActiveObservationsAtDepth';\nvar process = function () {\n    var depth = 0;\n    gatherActiveObservationsAtDepth(depth);\n    while (hasActiveObservations()) {\n        depth = broadcastActiveObservations();\n        gatherActiveObservationsAtDepth(depth);\n    }\n    if (hasSkippedObservations()) {\n        deliverResizeLoopError();\n    }\n    return depth > 0;\n};\nexport { process };\n", "var trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\nexport { queueMicroTask };\n", "import { queueMicroTask } from './queueMicroTask';\nvar queueResizeObserver = function (cb) {\n    queueMicroTask(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\nexport { queueResizeObserver };\n", "import { process } from './process';\nimport { global } from './global';\nimport { queueResizeObserver } from './queueResizeObserver';\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        queueResizeObserver(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = process();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\nexport { scheduler, updateCount };\n", "import { ResizeObserverBoxOptions } from './ResizeObserverBoxOptions';\nimport { calculateBoxSize } from './algorithms/calculateBoxSize';\nimport { isSVG, isReplacedElement } from './utils/element';\nvar skipNotifyOnElement = function (target) {\n    return !isSVG(target)\n        && !isReplacedElement(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = calculateBoxSize(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\nexport { ResizeObservation };\n", "var ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\nexport { ResizeObserverDetail };\n", "import { scheduler, updateCount } from './utils/scheduler';\nimport { ResizeObservation } from './ResizeObservation';\nimport { ResizeObserverDetail } from './ResizeObserverDetail';\nimport { resizeObservers } from './utils/resizeObservers';\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && resizeObservers.push(detail);\n            detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n            updateCount(1);\n            scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            updateCount(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\nexport { ResizeObserverController };\n", "import { ResizeObserverController } from './ResizeObserverController';\nimport { isElement } from './utils/element';\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\nexport { ResizeObserver };\n", "import { isClient } from '@vexip-ui/utils'\nimport { ResizeObserver } from '@juggle/resize-observer'\n\nexport type ResizeHandler = (entry: ResizeObserverEntry) => any\n\nconst handlerMap = new WeakMap<Element, ResizeHandler>()\n\nfunction handleResize(entries: ResizeObserverEntry[]) {\n  for (let i = 0, len = entries.length; i < len; ++i) {\n    const entry = entries[i]\n    const handler = handlerMap.get(entry.target)\n\n    if (typeof handler === 'function') {\n      handler(entry)\n    }\n  }\n}\n\nconst resizeObserver = new (isClient ? window.ResizeObserver || ResizeObserver : ResizeObserver)(\n  handleResize\n)\n\nexport function observeResize(el: Element, handler: ResizeHandler) {\n  handlerMap.set(el, handler)\n  resizeObserver.observe(el)\n}\n\nexport function unobserveResize(el: Element) {\n  if (handlerMap.has(el)) {\n    resizeObserver.unobserve(el)\n    handlerMap.delete(el)\n  }\n}\n\nexport function useResize() {\n  return {\n    observeResize,\n    unobserveResize\n  }\n}\n", "import { computed, ref } from 'vue'\n\nimport { isClient } from '@vexip-ui/utils'\nimport { observeResize } from './resize'\n\nimport type { Ref } from 'vue'\n\nconst rtl = ref(false)\nconst computedRtl: Ref<boolean> = computed(() => rtl.value)\n\nconst elId = '__rtl_observer__'\n\nexport function useRtl() {\n  if (isClient && !document.querySelector(`#${elId}`)) {\n    initObserver()\n  }\n\n  return { isRtl: computedRtl }\n}\n\nfunction initObserver() {\n  if (!isClient) return\n\n  const style = document.createElement('style')\n  const content = `#${elId} { width: 1px } html.rtl #${elId}, html[dir='rtl'] #${elId} { width: 2px }`\n\n  style.textContent = content\n  document.head.appendChild(style)\n\n  const observer = document.createElement('div')\n\n  observer.id = elId\n  observer.role = 'none'\n  observer.style.cssText =\n    'position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;'\n\n  observeResize(observer, () => {\n    if (!isClient) return\n\n    rtl.value =\n      document.documentElement.classList.contains('rtl') ||\n      document.documentElement.getAttribute('dir') === 'rtl'\n  })\n\n  document.body.appendChild(observer)\n}\n", "import { onMounted, ref, shallowRef, unref, watch, watchEffect } from 'vue'\n\nimport {\n  arrow,\n  autoUpdate,\n  computePosition,\n  flip,\n  hide,\n  offset,\n  platform,\n  shift\n} from '@floating-ui/dom'\nimport { useRtl } from './rtl'\nimport { isClient } from '@vexip-ui/utils'\n\nimport type { MaybeRef, Ref } from 'vue'\nimport type {\n  ComputePositionConfig,\n  Middleware,\n  OffsetOptions,\n  Placement,\n  ShiftOptions,\n  VirtualElement\n} from '@floating-ui/dom'\nimport type { TransferNode } from '@vexip-ui/utils'\n\nexport interface UsePopperOptions {\n  /**\n   * popper 元素出现的位置\n   */\n  placement: MaybeRef<Placement>,\n  /**\n   * popper 元素需要迁移至的目标选择器，为 true 时会迁移至 body\n   */\n  transfer?: MaybeRef<boolean | string>,\n  /**\n   * 设置是否为从右向左的阅读方向\n   */\n  isRtl?: MaybeRef<boolean>,\n  /**\n   * 包围元素，用于判断 clickoutside 事件\n   *\n   * 即使 popper 元素迁移至 wrapper 元素外部，点击 popper 元素时仍认为处于 wrapper 元素内部\n   */\n  wrapper?: Ref<HTMLElement | null | undefined>,\n  /**\n   * 设置 popper 元素为否需要 drop，此时 transform-origin 会自动调整\n   */\n  isDrop?: MaybeRef<boolean>,\n  /**\n   * 参考元素，popper 元素的位置计算依据\n   */\n  reference?: Ref<HTMLElement | VirtualElement | null | undefined>,\n  /**\n   * popper 元素\n   */\n  popper?: Ref<HTMLElement | null | undefined>,\n  /**\n   * arrow 元素\n   */\n  arrow?: Ref<HTMLElement | null | undefined>,\n  /**\n   * popper 元素的偏移量，可传入一个回调函数\n   */\n  offset?: MaybeRef<number[] | OffsetOptions>,\n  /**\n   * popper 元素是否限制在窗口内\n   */\n  shift?: MaybeRef<boolean | ShiftOptions>,\n  /**\n   * 设置是否自动更新 popper 元素\n   *\n   * @default false\n   */\n  autoUpdate?: boolean\n}\n\nexport type { Placement, VirtualElement }\n\nexport const placementWhileList = Object.freeze<Placement[]>([\n  'top',\n  'top-start',\n  'top-end',\n  'bottom',\n  'bottom-start',\n  'bottom-end',\n  'left',\n  'left-start',\n  'left-end',\n  'right',\n  'right-start',\n  'right-end'\n])\n\nexport function usePopper(initOptions: UsePopperOptions) {\n  const { transfer, wrapper, isDrop = false } = initOptions\n\n  const reference: Ref<HTMLElement | null | undefined> =\n    (initOptions.reference as any) ?? shallowRef(null)\n  const popper: Ref<HTMLElement | null | undefined> = initOptions.popper ?? shallowRef(null)\n  const arrowRef: Ref<HTMLElement | null | undefined> = initOptions.arrow ?? shallowRef(null)\n\n  const placement = ref(unref(initOptions.placement))\n  const transferTo = ref('')\n  const isRtl = initOptions.isRtl ?? useRtl().isRtl\n\n  if (wrapper) {\n    watchEffect(() => {\n      const wrapperEl = unref(wrapper)\n      const popperEl = unref(popper)\n\n      if (wrapperEl) {\n        (wrapperEl as TransferNode).__transferElement = popperEl\n      }\n    })\n  }\n\n  if (transfer != null) {\n    watch(\n      () => unref(transfer),\n      value => {\n        setTransferTo(value)\n        updatePopper()\n      }\n    )\n\n    setTransferTo(unref(transfer))\n  }\n\n  onMounted(() => {\n    requestAnimationFrame(() => {\n      watchEffect(updatePopperInternal)\n    })\n  })\n\n  let cleanup: (() => void) | undefined\n\n  async function updatePopperInternal() {\n    if (!isClient) return\n\n    cleanup?.()\n\n    const referenceEl = unref(reference)\n    const popperEl = unref(popper)\n\n    if (!referenceEl || !popperEl) return\n\n    const arrowEl = unref(arrowRef)\n\n    const middleware: Middleware[] = [flip()]\n\n    if (isDrop) {\n      middleware.push({\n        name: 'origin',\n        fn({ placement, elements }) {\n          const origin = setPopperDropOrigin(placement)\n\n          if (origin) {\n            elements.floating.style.transformOrigin = origin\n          }\n\n          return {}\n        }\n      })\n    }\n\n    if (initOptions.offset) {\n      let offsetOptions = unref(initOptions.offset)\n\n      if (Array.isArray(offsetOptions)) {\n        offsetOptions = {\n          mainAxis: offsetOptions[1],\n          crossAxis: offsetOptions[0]\n        }\n      }\n\n      middleware.push(offset(offsetOptions))\n    }\n\n    if (initOptions.shift) {\n      let shiftOptions = unref(initOptions.shift)\n\n      if (typeof shiftOptions === 'boolean') {\n        shiftOptions = {}\n      }\n\n      middleware.push(shift(shiftOptions))\n    }\n\n    if (arrowEl) {\n      middleware.push(arrow({ element: arrowEl }))\n    }\n\n    middleware.push(hide({ strategy: 'escaped' }))\n\n    const rtl = unref(isRtl) || false\n    const options: ComputePositionConfig = {\n      middleware,\n      placement: unref(initOptions.placement),\n      platform: {\n        ...platform,\n        isRTL: async () => rtl\n      }\n    }\n\n    const update = async () => {\n      const {\n        x,\n        y,\n        placement: activePlacement,\n        strategy,\n        middlewareData\n      } = await computePosition(referenceEl, popperEl, options)\n\n      if (unref(reference) !== referenceEl) {\n        if (unref(popper) === popperEl) {\n          Object.assign(popperEl.style, {\n            position: '',\n            top: '',\n            left: ''\n          })\n        }\n\n        return\n      }\n\n      const style: Partial<CSSStyleDeclaration> = {\n        position: strategy,\n        top: `${y}px`,\n        left: `${x}px`\n      }\n\n      // if (middlewareData.hide?.escaped) {\n      //   style.visibility = 'hidden'\n      // } else {\n      //   style.visibility = ''\n      // }\n\n      if (arrowEl) {\n        if (middlewareData.arrow) {\n          const { x, y } = middlewareData.arrow\n\n          Object.assign(arrowEl.style, {\n            top: y != null ? `${y}px` : '',\n            left: x != null ? `${x}px` : ''\n          })\n        } else {\n          Object.assign(arrowEl.style, { top: '', left: '' })\n        }\n      }\n\n      Object.assign(popperEl.style, style)\n      popperEl.dataset.popperPlacement = activePlacement\n      placement.value = activePlacement\n    }\n\n    if (initOptions.autoUpdate) {\n      cleanup = autoUpdate(referenceEl, popperEl, update)\n    }\n\n    await update()\n  }\n\n  const updatePopper = () => {\n    return new Promise<void>(resolve => {\n      requestAnimationFrame(() => {\n        updatePopperInternal().then(resolve)\n      })\n    })\n  }\n\n  function setTransferTo(value: boolean | string) {\n    transferTo.value = typeof value === 'boolean' ? (value ? 'body' : '') : value\n  }\n\n  // function normalizePlacement(placement: Placement, rtl: boolean) {\n  //   if (!rtl) return placement\n\n  //   let [start, end] = placement.split('-')\n\n  //   if (start === 'left' || start === 'right') {\n  //     start = start === 'left' ? 'right' : 'left'\n  //   } else {\n  //     if (!end) return placement\n\n  //     end = end === 'start' ? 'end' : 'start'\n  //   }\n\n  //   return `${start}-${end}` as Placement\n  // }\n\n  function setPopperDropOrigin(placement: Placement) {\n    if (placement !== 'left' && placement !== 'right') {\n      const [start, end] = placement.split('-')\n\n      return start === 'bottom' || (start !== 'top' && end === 'start')\n        ? 'center top'\n        : 'center bottom'\n    }\n  }\n\n  return {\n    wrapper,\n    reference,\n    popper,\n    placement,\n    transferTo,\n    updatePopper\n  }\n}\n", "import { reactive, ref, watch } from 'vue'\n\nimport { isClient } from '@vexip-ui/utils'\nimport { observeResize } from './resize'\n\nimport type { Ref } from 'vue'\nimport type { MaybeElement } from './shared/types'\n\nexport interface InitThemeOptions {\n  name: string,\n  rootClass?: string,\n  varsClass?: string\n}\n\nconst styleId = '__theme_style__'\nconst elClass = '__theme_observer__'\n\nconst elCache = new WeakMap<Element, Element>()\n\nexport function useTheme(wrapper?: MaybeElement) {\n  const theme = ref<string>()\n\n  if (isClient) {\n    wrapper = wrapper || document.body\n\n    let observer = elCache.get(wrapper)\n\n    if (!observer) {\n      observer = createObserver(theme)!\n      wrapper.appendChild(observer)\n      elCache.set(wrapper, observer)\n    }\n  }\n\n  return { theme }\n}\n\nconst activeThemes = reactive(new Map<string, string[]>())\nconst themeWidths = new Map<number, string>()\n\nwatch(activeThemes, () => {\n  if (!isClient) return\n\n  themeWidths.clear()\n\n  const prevStyle = document.head.querySelector(`#${styleId}`)\n\n  if (prevStyle) {\n    document.head.removeChild(prevStyle)\n  }\n\n  const style = document.createElement('style')\n\n  let content = `.${elClass} { width: 1px }`\n  let width = 1\n\n  for (const [name, [rootClass, varsClass]] of activeThemes.entries()) {\n    content += ` html.${rootClass} .${elClass}, .${varsClass} .${elClass} { width: ${++width}px }`\n    themeWidths.set(width, name)\n  }\n\n  style.textContent = content\n  style.id = styleId\n  document.head.appendChild(style)\n})\n\nexport function addActiveThemes(themes: (string | InitThemeOptions)[]) {\n  for (const theme of themes) {\n    const {\n      name,\n      rootClass = name,\n      varsClass = `vxp-theme-vars-${rootClass}`\n    } = typeof theme === 'string' ? ({ name: theme } as InitThemeOptions) : theme\n\n    activeThemes.set(name, [rootClass, varsClass])\n  }\n}\n\nexport function setActiveThemes(themes: (string | InitThemeOptions)[]) {\n  activeThemes.clear()\n  addActiveThemes(themes)\n}\n\nlet idCount = 0\n\nfunction getElId() {\n  return `__theme_observer_${idCount++}__`\n}\n\nfunction createObserver(theme: Ref<string | undefined>) {\n  if (!isClient) return\n\n  const observer = document.createElement('div')\n\n  observer.id = getElId()\n  observer.className = elClass\n  observer.role = 'none'\n  observer.style.cssText =\n    'position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;'\n\n  observeResize(observer, entry => {\n    if (!isClient) return\n\n    const width = entry.borderBoxSize?.[0].inlineSize ?? entry.contentRect.width\n\n    theme.value = themeWidths.get(width)\n  })\n\n  return observer\n}\n", "import { onScopeDispose } from 'vue'\n\n/**\n * 获取用于记录 `setTimeout` 返回值的对象，记录的定时器会在作用域消除时自动清理\n */\nexport function useSetTimeout() {\n  const timer: Record<string, any> = {}\n\n  onScopeDispose(() => {\n    Object.keys(timer).forEach(key => {\n      clearTimeout(timer[key])\n    })\n  })\n\n  return { timer }\n}\n\n/**\n * 获取用于记录 `setInterval` 返回值的对象，记录的定时器会在作用域消除时自动清理\n */\nexport function useSetInterval() {\n  const timer: Record<string, any> = {}\n\n  onScopeDispose(() => {\n    Object.keys(timer).forEach(key => {\n      clearInterval(timer[key])\n    })\n  })\n\n  return { timer }\n}\n\n/**\n * 获取用于记录 `requestAnimationFrame` 返回值的对象，记录的定时器会在作用域消除时自动清理\n */\nexport function useRaf() {\n  const timer: Record<string, any> = {}\n\n  onScopeDispose(() => {\n    Object.keys(timer).forEach(key => {\n      cancelAnimationFrame(timer[key])\n    })\n  })\n\n  return { timer }\n}\n\n/**\n * 获取三个分别用于记录 `setTimeout`、`setInterval` 和 `requestAnimationFrame` 返回值的对象\n *\n * 记录在这些对象上的定时器将会在作用域消除时自动清理\n */\nexport function useTimerRecord() {\n  const { timer: timeout } = useSetTimeout()\n  const { timer: interval } = useSetInterval()\n  const { timer: raf } = useRaf()\n\n  return { timeout, interval, raf }\n}\n", "import type { Ref } from 'vue'\n\nexport function useTriggerHandler(trigger: Ref<string>, currentVisible: Ref<boolean>, delay = 100) {\n  let timer: ReturnType<typeof setTimeout>\n\n  function handleTriggerEnter() {\n    if (trigger.value === 'hover') {\n      clearTimeout(timer)\n\n      timer = setTimeout(() => {\n        currentVisible.value = true\n      }, delay)\n    }\n  }\n\n  function handleTriggerLeave() {\n    if (trigger.value === 'hover') {\n      clearTimeout(timer)\n\n      timer = setTimeout(() => {\n        currentVisible.value = false\n      }, delay)\n    }\n  }\n\n  function handleTriggerClick() {\n    if (trigger.value === 'click') {\n      currentVisible.value = !currentVisible.value\n    }\n  }\n\n  return {\n    handleTriggerEnter,\n    handleTriggerLeave,\n    handleTriggerClick\n  }\n}\n", "import { computed, onScopeDispose, ref, unref, watch } from 'vue'\n\nimport { createBITree, isDefined, nextFrameOnce, noop } from '@vexip-ui/utils'\nimport { isHiddenElement } from './display'\nimport { observeResize, unobserveResize } from './resize'\n\nimport type { MaybeRef } from 'vue'\n\ntype Key = number | string | symbol\ntype Data = Record<string, any>\ntype Behavior = ScrollToOptions['behavior']\n\nexport interface VirtualOptions<T extends Data> {\n  /**\n   * 虚拟滚动的元素\n   */\n  items: MaybeRef<T[]>,\n  /**\n   * 设置元素的最小高度\n   */\n  itemSize: MaybeRef<number>,\n  /**\n   * 设置元素是否为固定高度，固定高度时不处理 resize\n   */\n  itemFixed: MaybeRef<boolean>,\n  /**\n   * 元素的主键\n   */\n  idKey: MaybeRef<keyof T>,\n  /**\n   * 默认停留在的元素的主键，未实现\n   */\n  defaultKeyAt?: Key,\n  /**\n   * 设置前后的缓冲元素的个数\n   */\n  bufferSize?: MaybeRef<number>,\n  /**\n   * 虚拟滚动的包围元素\n   */\n  wrapper?: MaybeRef<HTMLElement | null | undefined>,\n  /**\n   * 是否自动观察 wrapper 缩放\n   *\n   * @default true\n   */\n  autoResize?: boolean\n}\n\nexport function useVirtual<T extends Data = Data>(options: VirtualOptions<T>) {\n  const {\n    items,\n    itemSize,\n    itemFixed,\n    idKey,\n    defaultKeyAt,\n    bufferSize = ref(5),\n    wrapper = ref(null),\n    autoResize = true\n  } = options\n\n  const indexMap = computed(() => {\n    const itemList = unref(items)\n    const length = itemList.length\n    const keyField = unref(idKey)\n    const map = new Map<Key, number>()\n\n    for (let i = 0; i < length; ++i) {\n      map.set(itemList[i][keyField], i)\n    }\n\n    return map\n  })\n  const visibleHeight = ref(0)\n  const heightDiffMap = new Map<Key, number>()\n  const heightTree = computed(() => {\n    const itemList = unref(items)\n    const length = itemList.length\n    const keyField = unref(idKey)\n    const tree = createBITree(length, unref(itemSize))\n\n    for (let i = 0; i < length; ++i) {\n      const key = itemList[i][keyField]\n      const heightDiff = heightDiffMap.get(key)\n\n      if (heightDiff) {\n        tree.add(i, heightDiff)\n      }\n    }\n\n    return tree\n  })\n  const treeUpdateDep = ref(0)\n  const scrollOffset = ref(0)\n  const startIndex = computed(() => {\n    return Math.max(\n      heightTree.value.boundIndex(scrollOffset.value) - Math.max(unref(bufferSize), 0),\n      0\n    )\n  })\n  const visibleItems = computed(() => {\n    if (!visibleHeight.value || visibleHeight.value < 0) return []\n\n    const unrefItems = unref(items)\n    const endIndex = Math.min(\n      heightTree.value.boundIndex(scrollOffset.value + visibleHeight.value) +\n        1 +\n        Math.max(unref(bufferSize), 0),\n      unrefItems.length\n    )\n\n    return unrefItems.slice(startIndex.value, endIndex)\n  })\n  const listStyle = computed(() => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    treeUpdateDep.value\n\n    const height = heightTree.value.sum()\n    const fixed = unref(itemFixed)\n\n    return {\n      height: fixed ? `${height}px` : undefined,\n      minHeight: fixed ? undefined : `${height}px`,\n      boxSizing: 'content-box'\n    } as const\n  })\n  const itemsStyle = computed(() => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    treeUpdateDep.value\n\n    return {\n      transform: `translate3d(0, ${heightTree.value.sum(startIndex.value)}px, 0)`\n    }\n  })\n\n  if (autoResize) {\n    let unobserve = noop\n\n    const stopWatch = watch(\n      () => unref(wrapper),\n      el => {\n        unobserve()\n\n        if (!el) return\n\n        observeResize(el, handleResize)\n\n        unobserve = () => {\n          unobserveResize(el)\n          unobserve = noop\n        }\n\n        if (isDefined(defaultKeyAt)) {\n          scrollToKey(defaultKeyAt)\n        }\n      },\n      { immediate: true, flush: 'post' }\n    )\n\n    onScopeDispose(() => {\n      stopWatch()\n      unobserve()\n    })\n  }\n\n  function syncScrollOffset() {\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      scrollOffset.value = wrapperEl.scrollTop\n    }\n  }\n\n  function handleScroll() {\n    nextFrameOnce(syncScrollOffset)\n  }\n\n  function handleResize(entry: ResizeObserverEntry) {\n    if (\n      isHiddenElement(entry.target as HTMLElement) ||\n      entry.contentRect.height === visibleHeight.value\n    ) {\n      return\n    }\n\n    visibleHeight.value = entry.contentRect.height\n  }\n\n  function handleItemResize(key: Key, entry: ResizeObserverEntry) {\n    if (unref(itemFixed)) return\n\n    const index = indexMap.value.get(key)!\n    const tree = heightTree.value\n    const prevHeight = tree.get(index)\n    const height = entry.borderBoxSize?.[0]?.blockSize ?? entry.contentRect.height\n\n    if (height === prevHeight) return\n\n    if (isHiddenElement(entry.target as HTMLElement)) {\n      if (prevHeight) {\n        tree.add(index, -prevHeight)\n        treeUpdateDep.value++\n      }\n\n      return\n    }\n\n    const diff = height - unref(itemSize)\n    const delta = height - prevHeight\n\n    if (diff) {\n      heightDiffMap.set(key, diff)\n    } else {\n      heightDiffMap.delete(key)\n    }\n\n    if (!delta) return\n\n    tree.add(index, delta)\n    treeUpdateDep.value++\n\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      const prevTop = tree.sum(index)\n\n      if (wrapperEl.scrollTop > prevTop) {\n        wrapperEl.scrollBy(0, delta)\n      }\n\n      scrollOffset.value = wrapperEl.scrollTop\n    }\n  }\n\n  function scrollTo(top: number, behavior?: Behavior) {\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      wrapperEl.scrollTo({\n        behavior,\n        top,\n        left: 0\n      })\n    }\n  }\n\n  function scrollBy(delta: number, behavior?: Behavior) {\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      wrapperEl.scrollBy({\n        behavior,\n        top: delta,\n        left: 0\n      })\n    }\n  }\n\n  function scrollToKey(key: Key, behavior?: Behavior) {\n    const index = indexMap.value.get(key)\n\n    if (index != null) {\n      scrollToIndex(index, behavior)\n    }\n  }\n\n  function scrollToIndex(index: number, behavior?: Behavior) {\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      wrapperEl.scrollTo({\n        behavior,\n        top: heightTree.value.sum(index),\n        left: 0\n      })\n    }\n  }\n\n  function ensureIndexInView(index: number, behavior?: Behavior) {\n    const wrapperEl = unref(wrapper)\n\n    if (!wrapperEl) return\n\n    const tree = heightTree.value\n    const viewTop = wrapperEl.scrollTop\n    const top = tree.sum(index)\n\n    if (top < viewTop) {\n      scrollToIndex(index, behavior)\n      return\n    }\n\n    const viewHeight = wrapperEl.offsetHeight\n    const viewBottom = viewTop + viewHeight\n    const bottom = tree.sum(index + 1)\n\n    if (bottom > viewBottom) {\n      scrollTo(bottom - viewHeight, behavior)\n    }\n  }\n\n  function ensureKeyInView(key: Key, behavior?: Behavior) {\n    const index = indexMap.value.get(key)\n\n    if (index != null) {\n      ensureIndexInView(index, behavior)\n    }\n  }\n\n  return {\n    wrapper,\n    indexMap,\n    heightTree,\n    startIndex,\n    scrollOffset,\n    visibleItems,\n    listStyle,\n    itemsStyle,\n    handleScroll,\n    handleResize,\n    handleItemResize,\n    scrollTo,\n    scrollBy,\n    scrollToKey,\n    scrollToIndex,\n    ensureIndexInView,\n    ensureKeyInView\n  }\n}\n"],
  "mappings": "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",
  "names": ["y", "At", "w", "t", "ot", "G", "mt", "qn", "e", "f", "u", "d", "me", "Xe", "Ze", "_r", "kr", "dt", "jr", "Xt", "D", "Vt", "un", "Zr", "to", "useListener", "target", "event", "listener", "options", "noop", "remove", "stopWatch", "watch", "unref", "el", "stop", "getCurrentScope", "onScopeDispose", "CLICK_OUTSIDE", "elements", "isClient", "CLICK_TYPE", "path", "dispatchEvent", "useClickOutside", "handler", "ref", "useDisplay", "displayInit", "element", "observer", "onMounted", "nextTick", "hiddenParentNode", "queryOutsideHiddenElement", "onBeforeUnmount", "parentElement", "isHiddenElement", "createSlotRender", "slots", "names", "fallback", "name", "params", "renderSlot", "vnodes", "ensureArray", "flatVNodes", "children", "result", "loop", "vnode", "isVNode", "Comment", "createTextVNode", "Fragment", "unrefElement", "plain", "proxyExposed", "_", "key", "_a", "_b", "_c", "watchPauseable", "args", "active", "handle", "pause", "resume", "callbackArgs", "resolve", "reject", "readonly", "functionsMap", "map", "m", "supported", "notSupportedResult", "computed", "states", "subscriptions", "ELEMENT", "EVENT", "state", "full", "useFullScreen", "targetRef", "isRef", "REQUEST", "EXIT", "old", "exit", "enter", "force", "toggle", "useHover", "wrapper", "isHover", "enterWrapper", "leaveWrapper", "observerCache", "spaceRE", "unitRE", "useIntersection", "root", "threshold", "margin", "normalizeMargin", "thresholdCache", "marginCache", "handleIntersect", "handlers", "disconnect", "parts", "i", "part", "toNumber", "entries", "len", "entry", "useManualRef", "updateSet", "manualRef", "value", "customRef", "track", "trigger", "origin", "update", "newValue", "triggerUpdate", "defaultAliasMap", "separatorRE", "splitRE", "internalProps", "useModifier", "autoReset", "capture", "passive", "onKeyDown", "onKeyUp", "aliasMap", "activeKeys", "reactive", "metaDeps", "modifier", "resetAll", "setModifier", "updateModifier", "keys", "modifierProxy", "prop", "receiver", "useMounted", "wait", "isMounted", "mount", "disableEvent", "useMoving", "x", "lazy", "stopMouse", "stopTouch", "moving", "internalState", "current", "record", "throttleMove", "throttle", "updateState", "start", "move", "end", "clientX", "clientY", "xStart", "yStart", "clientXStart", "clientYStart", "deltaX", "deltaY", "registered", "pageX", "pageY", "throttleHandler", "register", "unregister", "usePointer", "sides", "min", "max", "round", "floor", "createCoords", "v", "oppositeSideMap", "oppositeAlignmentMap", "clamp", "evaluate", "param", "getSide", "placement", "getAlignment", "getOppositeAxis", "axis", "getAxisLength", "getSideAxis", "getAlignmentAxis", "getAlignmentSides", "rects", "rtl", "alignment", "alignmentAxis", "length", "mainAlignmentSide", "getOppositePlacement", "getExpandedPlacements", "oppositePlacement", "getOppositeAlignmentPlacement", "getSideList", "side", "isStart", "lr", "rl", "tb", "bt", "getOppositeAxisPlacements", "flipAlignment", "direction", "list", "expandPaddingObject", "padding", "getPaddingObject", "rectToClientRect", "rect", "computeCoordsFromPlacement", "_ref", "reference", "floating", "sideAxis", "alignLength", "isVertical", "commonX", "commonY", "commonAlign", "coords", "computePosition", "config", "strategy", "middleware", "platform", "validMiddleware", "statefulPlacement", "middlewareData", "resetCount", "fn", "nextX", "nextY", "data", "reset", "detectOverflow", "_await$platform$isEle", "boundary", "rootBoundary", "elementContext", "altBoundary", "paddingObject", "clippingClientRect", "offsetParent", "offsetScale", "elementClientRect", "arrow", "arrowDimensions", "isYAxis", "minProp", "maxProp", "clientProp", "endDiff", "startDiff", "arrowOffsetParent", "clientSize", "centerToReference", "largestPossiblePadding", "minPadding", "maxPadding", "min$1", "center", "offset", "shouldAddOffset", "alignmentOffset", "flip", "_middlewareData$arrow", "_middlewareData$flip", "initialPlacement", "checkMainAxis", "checkCrossAxis", "specifiedFallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "detectOverflowOptions", "isBasePlacement", "fallbackPlacements", "placements", "overflow", "overflows", "overflowsData", "_middlewareData$flip2", "_overflowsData$filter", "nextIndex", "nextPlacement", "resetPlacement", "a", "b", "_overflowsData$map$so", "acc", "getSideOffsets", "isAnySideFullyClipped", "hide", "offsets", "convertValueToCoords", "mainAxisMulti", "crossAxisMulti", "rawValue", "mainAxis", "crossAxis", "_middlewareData$offse", "diffCoords", "shift", "limiter", "mainAxisCoord", "crossAxisCoord", "minSide", "maxSide", "limitedCoords", "getNodeName", "node", "isNode", "getWindow", "_node$ownerDocument", "getDocumentElement", "isElement", "isHTMLElement", "isShadowRoot", "isOverflowElement", "overflowX", "overflowY", "display", "getComputedStyle", "isTableElement", "isContainingBlock", "webkit", "isWebKit", "css", "getContainingBlock", "currentNode", "getParentNode", "isLastTraversableNode", "getNodeScroll", "getNearestOverflowAncestor", "parentNode", "getOverflowAncestors", "traverseIframes", "_node$ownerDocument2", "scrollableAncestor", "isBody", "win", "getCssDimensions", "width", "height", "hasOffset", "offsetWidth", "offsetHeight", "shouldFallback", "unwrapElement", "getScale", "domElement", "$", "noOffsets", "getVisualOffsets", "shouldAddVisualOffsets", "isFixed", "floatingOffsetParent", "getBoundingClientRect", "includeScale", "isFixedStrategy", "clientRect", "scale", "visualOffsets", "offsetWin", "currentIFrame", "iframeScale", "iframeRect", "left", "top", "convertOffsetParentRelativeRectToViewportRelativeRect", "isOffsetParentAnElement", "documentElement", "scroll", "offsetRect", "getClientRects", "getWindowScrollBarX", "getDocumentRect", "html", "body", "getViewportRect", "visualViewport", "visualViewportBased", "getInnerBoundingClientRect", "getClientRectFromClippingAncestor", "clippingAncestor", "hasFixedPositionAncestor", "stopNode", "getClippingElementAncestors", "cache", "cachedResult", "currentContainingBlockComputedStyle", "elementIsFixed", "computedStyle", "currentNodeIsContaining", "ancestor", "getClippingRect", "clippingAncestors", "firstClippingAncestor", "clippingRect", "accRect", "getDimensions", "getRectRelativeToOffsetParent", "getTrueOffsetParent", "polyfill", "getOffsetParent", "window", "getElementRects", "getOffsetParentFn", "getDimensionsFn", "isRTL", "observeMove", "onMove", "io", "timeoutId", "cleanup", "refresh", "skip", "insetTop", "insetRight", "insetBottom", "insetLeft", "isFirstUpdate", "handleObserve", "ratio", "autoUpdate", "ancestorScroll", "ancestorResize", "elementResize", "layoutShift", "animationFrame", "referenceEl", "ancestors", "cleanupIo", "reobserveFrame", "resizeObserver", "firstEntry", "frameId", "prevRefRect", "frameLoop", "nextRefRect", "mergedOptions", "platformWithCache", "computePosition$1", "resizeObservers", "hasActiveObservations", "ro", "hasSkippedObservations", "msg", "deliverResizeLoopError", "ResizeObserverBoxOptions", "freeze", "obj", "ResizeObserverSize", "inlineSize", "blockSize", "DOMRectReadOnly", "right", "bottom", "rectangle", "isSVG", "isHidden", "scope", "isReplacedElement", "global", "scrollRegexp", "verticalRegexp", "IE", "parseDimension", "pixel", "size", "switchSizes", "zeroBoxes", "calculateBoxSizes", "forceRecalculation", "cs", "svg", "removePadding", "canScrollVertically", "canScrollHorizontally", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "borderTop", "borderRight", "borderBottom", "borderLeft", "horizontalPadding", "verticalPadding", "horizontalBorderArea", "verticalBorderArea", "horizontalScrollbarThickness", "verticalScrollbarThickness", "widthReduction", "heightReduction", "contentWidth", "contentHeight", "borderBoxWidth", "borderBoxHeight", "boxes", "calculateBoxSize", "observedBox", "borderBoxSize", "contentBoxSize", "devicePixelContentBoxSize", "ResizeObserverEntry", "calculateDepthForNode", "depth", "parent", "broadcastActiveObservations", "shallowestDepth", "callbacks", "targetDepth", "_i", "callbacks_1", "callback", "gatherActiveObservationsAtDepth", "process", "notify", "cb", "queueMicroTask", "toggle_1", "el_1", "queueResizeObserver", "watching", "isWatching", "CATCH_PERIOD", "observerConfig", "events", "time", "timeout", "scheduled", "Scheduler", "_this", "until", "elementsHaveResized", "scheduler", "updateCount", "n", "skipNotifyOnElement", "ResizeObservation", "ResizeObserverDetail", "observerMap", "getObservationIndex", "observationTargets", "ResizeObserverController", "detail", "firstObservation", "index", "lastObservation", "ResizeObserver", "handlerMap", "handleResize", "observeResize", "unobserveResize", "useResize", "computedRtl", "elId", "useRtl", "initObserver", "style", "content", "placementWhileList", "usePopper", "initOptions", "transfer", "isDrop", "shallowRef", "popper", "arrowRef", "transferTo", "isRtl", "watchEffect", "wrapperEl", "popperEl", "setTransferTo", "updatePopper", "updatePopperInternal", "arrowEl", "setPopperDropOrigin", "offsetOptions", "shiftOptions", "activePlacement", "y2", "styleId", "elClass", "elCache", "useTheme", "theme", "createObserver", "activeThemes", "themeWidths", "prevStyle", "rootClass", "varsClass", "addActiveThemes", "themes", "setActiveThemes", "idCount", "getElId", "useSetTimeout", "timer", "useSetInterval", "useRaf", "useTimerRecord", "interval", "raf", "useTriggerHandler", "currentVisible", "delay", "handleTriggerEnter", "handleTriggerLeave", "handleTriggerClick", "useVirtual", "items", "itemSize", "itemFixed", "idKey", "defaultKeyAt", "bufferSize", "autoResize", "indexMap", "itemList", "keyField", "visibleHeight", "heightDiffMap", "heightTree", "tree", "createBITree", "heightDiff", "treeUpdateDep", "scrollOffset", "startIndex", "visibleItems", "unrefItems", "endIndex", "listStyle", "fixed", "itemsStyle", "unobserve", "isDefined", "scrollToKey", "syncScrollOffset", "handleScroll", "nextFrameOnce", "handleItemResize", "prevHeight", "diff", "delta", "prevTop", "scrollTo", "behavior", "scrollBy", "scrollToIndex", "ensureIndexInView", "viewTop", "viewHeight", "viewBottom", "ensureKeyInView"]
}
